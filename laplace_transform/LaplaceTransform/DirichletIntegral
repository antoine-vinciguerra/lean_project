import Mathlib.Tactic.Basic

import Mathlib.MeasureTheory.Integral.Bochner.Basic
import Mathlib.MeasureTheory.Integral.Bochner.L1
import Mathlib.MeasureTheory.Integral.Bochner.VitaliCaratheodory
import Mathlib.MeasureTheory.Integral.Bochner.ContinuousLinearMap
import Mathlib.MeasureTheory.Integral.Lebesgue.Basic
import Mathlib.MeasureTheory.Integral.IntervalIntegral
import Mathlib.MeasureTheory.Integral.Lebesgue.Countable
import Mathlib.Dynamics.Ergodic.MeasurePreserving
import Mathlib.MeasureTheory.Integral.Lebesgue.Basic
import Mathlib.MeasureTheory.Integral.Lebesgue.Norm
import Mathlib.MeasureTheory.Measure.Lebesgue.Complex
import Mathlib.MeasureTheory.Integral.Prod
import Mathlib.Analysis.Calculus.ParametricIntegral
import Mathlib.Topology.Instances.Complex
import Mathlib.Analysis.SpecialFunctions.Exponential
import Mathlib.Algebra.GroupWithZero.Action.Defs
import Mathlib.Analysis.Complex.Basic
import Mathlib.Analysis.Fourier.FourierTransform
import Mathlib.Analysis.SpecialFunctions.ImproperIntegrals

import Mathlib.Algebra.Group.Basic
import Mathlib.Algebra.Group.Semiconj.Defs
import Mathlib.Algebra.Group.Commute.Basic
import Mathlib.Algebra.Group.Commute.Defs
import LaplaceTransform.LaplaceTransformDef
import Mathlib.MeasureTheory.Measure.Complex
import Mathlib.Analysis.Complex.Exponential
import Mathlib.Order.Filter.Prod

import Mathlib.Data.Complex.Basic
import Mathlib.Data.List.Defs
import Mathlib.Analysis.SpecialFunctions.Integrals.Basic
import Mathlib.Order.Filter.Basic

import Mathlib.Analysis.Asymptotics.Defs
import Mathlib.Analysis.Asymptotics.Lemmas
import Mathlib.Analysis.Asymptotics.SpecificAsymptotics
/-! # The Dirichlet Integral
-/


@[expose] public section


noncomputable section


open MeasureTheory Filter
open MeasureTheory Set
open MeasureTheory Complex Real Topology Filter
open scoped Topology
open Complex

noncomputable def DirichletSin : ‚Ñù ‚Üí ‚Ñù :=
  fun x‚Ü¶1/2 + 1/œÄ * ‚à´ t in  (0).. (x), sinc t

def Dirichlet_Val : ‚Ñù := lim (atTop.map (fun T ‚Ü¶ ‚à´ t in (0)..T, sinc t))

noncomputable def HeavisidePerso (x : ‚Ñù) : ‚Ñù :=
  if x > 0 then 1 else if x = 0 then 1/2 else 0


lemma integrable_sinc_sq : IntegrableOn (fun (t:‚Ñù) => (sinc t)^2) (Ioi 0) := by
  let s1 : Set ‚Ñù := Ioc 0 1
  let s2 : Set ‚Ñù := Ioi 1
  have h_union : Ioi 0 = s1 ‚à™ s2 := (Ioc_union_Ioi_eq_Ioi (by norm_num)).symm
  have integrable_s1: IntegrableOn (fun t ‚Ü¶ sinc t ^ 2) s1 volume:= by
    rw[‚Üê intervalIntegrable_iff_integrableOn_Ioc_of_le ]
    apply Continuous.intervalIntegrable
    have h_cont : Continuous (fun t ‚Ü¶ sinc t ^ 2) := continuous_sinc.pow 2
    exact h_cont
    simp
  have integrable_s2: IntegrableOn (fun t ‚Ü¶ sinc t ^ 2) s2 volume:= by
    unfold s2
    have h_int_inv_sq : IntegrableOn (fun (t:‚Ñù) => 1 / t^(2:‚Ñù)) s2 volume := by
      have : (fun t: ‚Ñù ‚Ü¶(1:‚Ñù) / t^(2:‚Ñù)) = fun t: ‚Ñù ‚Ü¶ (t^(-2: ‚Ñù)):= by
        funext t
        simp
        rfl
      simp_rw[this]
      rw [integrableOn_Ioi_rpow_iff (zero_lt_one : 0 < (1 : ‚Ñù))]
      norm_num
    apply MeasureTheory.Integrable.mono h_int_inv_sq
    ¬∑ apply (continuous_sinc.pow 2).continuousOn.aestronglyMeasurable
      exact measurableSet_Ioi
    ¬∑ rw [ae_restrict_iff' measurableSet_Ioi]
      refine Filter.Eventually.of_forall (fun t ht_mem => ?_)
      unfold sinc
      rw [mem_Ioi] at ht_mem
      simp [(by linarith : t ‚â† 0)]
      have h_pos : 0 < t := by linarith
      have h_t2_pos : 0 < t^2 := by positivity
      have h_t2_abs_eq_t2: |t ^ 2|=t^2 := by
        rw [abs_of_nonneg]
        exact h_t2_pos.le
      rw [div_pow, ‚Üêabs_pow, ‚Üêabs_pow]
      rw[h_t2_abs_eq_t2]
      simp
      field_simp
      rw [‚Üê sq_abs (Real.sin t)]
      rw[‚Üê one_pow 2]
      simp[pow_le_pow_iff_left ]
      rw[abs_le]
      constructor
      exact Real.neg_one_le_sin t
      exact Real.sin_le_one t
  have:= IntegrableOn.union integrable_s1 integrable_s2
  rw[‚Üê h_union] at this
  exact this

lemma deriv_sin_sq (t : ‚Ñù) : HasDerivAt (fun x => Real.sin x ^ 2) (Real.sin (2 * t)) t := by
  have h := (Real.hasDerivAt_sin t).pow 2
  simp at h
  rw [‚Üê Real.sin_two_mul] at h
  exact h

lemma deriv_neg_inv {t : ‚Ñù} (ht : t ‚â† 0) : HasDerivAt (fun x => -1 / x) (1 / t ^ 2) t := by
  have h :=  (hasDerivAt_inv ht).neg
  field_simp at h
  have neg_inside: (-fun y:‚Ñù ‚Ü¶ 1 / y)= (fun y:‚Ñù ‚Ü¶ -1 / y):= by
    funext x
    simp
    field_simp
  rw[neg_inside] at h
  exact h

lemma integral_sinc_sq_eq_dirichlet_bounded {a T : ‚Ñù} (ha : 0 < a) (hT : a ‚â§ T) :
    ‚à´ t in a..T, (Real.sinc t)^2 =
    ((Real.sinc a)^2 * a -(Real.sinc T)^2   * T) + ‚à´ t in a..T, Real.sin (2 * t) / t := by
    unfold sinc

    have h_sinc_eq : ‚àÄ t ‚àà Set.uIcc a T, (if t = 0 then 1 else Real.sin t / t) = Real.sin t / t := by
      intro t ht
      have : t ‚â† 0 := by
        rw [Set.uIcc_of_le hT] at ht
        linarith [ha, ht.1]
      split_ifs with h_cond
      ¬∑ contradiction
      ¬∑ rfl
    rw[h_sinc_eq]
    rw[h_sinc_eq]

    have : ‚à´ (t : ‚Ñù) in a..T, (if t = 0 then 1 else Real.sin t / t) ^ 2
     =‚à´ (t : ‚Ñù) in a..T, ( Real.sin t / t) ^ 2:= by
      apply intervalIntegral.integral_congr
      intro t ht
      have h_val := h_sinc_eq t ht
      simp [h_val]
    rw[this]


    let u := fun t => Real.sin t ^ 2
    let v := fun t: ‚Ñù  => -1 / t
    let u' := fun t => Real.sin (2 * t)
    let v' := fun t: ‚Ñù  => 1 / t ^ 2
    have h_left : ‚à´ t in a..T, (Real.sin t / t )^2 = ‚à´ t in a..T, u t * v' t := by
      apply intervalIntegral.integral_congr
      intro t _
      field_simp [u, v']
      ring
    rw [h_left]

    have h_deriv_u : ‚àÄ x ‚àà uIcc a T, HasDerivAt u (u' x) x:= by
      unfold u u'
      intro x hx
      exact deriv_sin_sq x
    have h_deriv_v : ‚àÄ x ‚àà uIcc a T, HasDerivAt v (v' x) x:= by
      unfold v v'
      intro x hx
      rw [uIcc_of_le hT] at hx
      have hx_neq0 : x ‚â† 0 := by
       exact ne_of_gt (ha.trans_le hx.1)
      exact deriv_neg_inv hx_neq0
    have hu'_integrable : IntervalIntegrable u' volume a T:= by
      unfold u'
      apply ContinuousOn.intervalIntegrable
      fun_prop
    have hv'_integrable :IntervalIntegrable v' volume a T:= by
      unfold v'
      apply ContinuousOn.intervalIntegrable
      have : ‚àÄ x ‚àà Icc a T, x ^ 2 ‚â† 0:= by
        intro x hx
        have hx_neq0 : x ‚â† 0 := by
          exact ne_of_gt (ha.trans_le hx.1)
        exact pow_ne_zero 2 hx_neq0
      apply ContinuousOn.div
      fun_prop
      fun_prop
      rw [uIcc_of_le hT]
      exact this


    rw [intervalIntegral.integral_mul_deriv_eq_deriv_mul h_deriv_u h_deriv_v hu'_integrable hv'_integrable]
    unfold u v u'
    field_simp
    simp
    ring
    simp
    simp

lemma sinc_bounded_change_interval{a T : ‚Ñù} (ha : 0 < a) (hT : a ‚â§ T) : (‚à´ t in a..T, Real.sin (2 * t) / t)= ‚à´ t in (2*a).. (2*T), Real.sinc t := by
  let f:= fun t ‚Ü¶ Real.sin (t) / (t)

  have : (‚à´ t in a..T, Real.sin (2 * t) / t)= 2*(‚à´ t in a..T, f (2 * t)):= by
    unfold f
    rw[‚Üê intervalIntegral.integral_const_mul]
    congr
    funext t
    field_simp
  rw[this]
  rw [intervalIntegral.integral_comp_mul_left]
  simp
  unfold f
  apply intervalIntegral.integral_congr
  intro t ht
  simp
  have h2T: 2*a ‚â§ 2*T := by linarith
  have h : t ‚â† 0 := by
    rw [Set.uIcc_of_le h2T] at ht
    linarith [ha, ht.1]
  unfold sinc
  simp[h]
  simp

lemma limit_sinc_sq_mul_self_zero :
    Tendsto (fun a => (Real.sinc a)^2 * a) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) := by
  have h_cont : ContinuousAt (fun a => (Real.sinc a)^2 * a) 0 := by
    fun_prop
  have h_lim : Tendsto (fun a => (Real.sinc a)^2 * a) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) := by
    have h_val : (Real.sinc 0)^2 * 0 = 0 := by simp
    rw [‚Üê h_val]
    apply Tendsto.mono_left
    ¬∑ exact h_cont.tendsto
    ¬∑ simp
      exact nhdsWithin_le_nhds
  exact h_lim
lemma limit_sinc_sq_mul_self_atTop :
    Tendsto (fun T => (Real.sinc T)^2 * T) atTop (nhds 0) := by
    have h_eq : ‚àÄ·∂† T in atTop, (Real.sinc T)^2 * T = (Real.sin T)^2 / T := by
      filter_upwards [eventually_gt_atTop 0] with T hT
      unfold Real.sinc
      simp [hT.ne.symm]
      field_simp
    rw [tendsto_congr' h_eq]
    apply tendsto_of_tendsto_of_tendsto_of_le_of_le'
    ¬∑ exact tendsto_const_nhds
    ¬∑ exact tendsto_inv_atTop_zero
    ¬∑ filter_upwards [eventually_gt_atTop 0] with x hx
      positivity
    ¬∑ filter_upwards [eventually_gt_atTop 0] with x hx
      field_simp
      rw [‚Üê sq_abs (Real.sin x)]
      rw[‚Üê one_pow 2]
      simp[pow_le_pow_iff_left ]
      rw[abs_le]
      constructor
      exact Real.neg_one_le_sin x
      exact Real.sin_le_one x

lemma limit_sinc_zero (T:‚Ñù) (hT: T>0): Tendsto (fun (a : ‚Ñù) ‚Ü¶ ‚à´ t in a..T, Real.sinc t) (ùìù[>] 0) (ùìù (‚à´ t in 0..T, Real.sinc t)) := by
  let I := Set.uIcc (0:‚Ñù) (T:‚Ñù)
  have h_int : IntegrableOn Real.sinc I :=
    Real.continuous_sinc.integrableOn_Icc
  have h_cont := intervalIntegral.continuousOn_primitive_interval_left h_int
  have h_integral: Tendsto (fun (a : ‚Ñù) ‚Ü¶ ‚à´ t in a..T, Real.sinc t) (ùìù[>] 0) (ùìù (‚à´ t in 0..T, Real.sinc t)) := by
    apply (h_cont 0 (by simp [I])).mono_left
    have h_eventually_lt_T : ‚àÄ·∂† x in ùìù[>] (0 : ‚Ñù), x < T:= eventually_nhdsWithin_of_eventually_nhds (Iio_mem_nhds hT)
    rw [nhdsWithin_le_iff]
    filter_upwards [self_mem_nhdsWithin, h_eventually_lt_T] with x hx_pos hx_lt_T
    rw [Set.mem_Ioi] at hx_pos
    have x_min: min 0 T ‚â§  x:= by
      have h_min : min 0 T= 0 := min_eq_left (le_of_lt hT)
      linarith
    have x_max: max 0 T ‚â•  x:= by
      have h_min : max 0 T= T := max_eq_right (le_of_lt hT)
      linarith
    exact ‚ü®x_min, x_max‚ü©
  exact h_integral


lemma limit_sincsq_zero (T:‚Ñù) (hT: T>0): Tendsto (fun (a : ‚Ñù) ‚Ü¶ ‚à´ t in a/2..T/2, (Real.sinc t)^2) (ùìù[>] 0) (ùìù (‚à´ t in 0..T/2, (Real.sinc t)^2)) := by
  have hT2: T/2>0:= by
    linarith
  let I := Set.uIcc (0:‚Ñù) (T/2:‚Ñù)
  let f:= fun t‚Ü¶ (Real.sinc t)^2
  have h_int : IntegrableOn f I := by
    have h_cont_f : Continuous f := by
      exact Real.continuous_sinc.pow 2
    apply h_cont_f.integrableOn_Icc

  have h_cont := intervalIntegral.continuousOn_primitive_interval_left h_int
  have h_integral: Tendsto (fun (a : ‚Ñù) ‚Ü¶ ‚à´ t in a..T/2, (Real.sinc t)^2) (ùìù[>] 0) (ùìù (‚à´ t in 0..T/2, (Real.sinc t)^2)) := by
    apply (h_cont 0 (by simp [I])).mono_left
    have h_eventually_lt_T : ‚àÄ·∂† x in ùìù[>] (0 : ‚Ñù), x < T/2:= eventually_nhdsWithin_of_eventually_nhds (Iio_mem_nhds hT2)
    rw [nhdsWithin_le_iff]
    filter_upwards [self_mem_nhdsWithin, h_eventually_lt_T] with x hx_pos hx_lt_T
    rw [Set.mem_Ioi] at hx_pos
    have x_min: min 0 (T/2) ‚â§  x:= by
      have h_min : min 0 (T/2)= 0 := min_eq_left (le_of_lt hT2)
      linarith
    have x_max: max 0 (T/2) ‚â•  x:= by
      have h_min : max 0 (T/2)= T/2 :=     max_eq_right (le_of_lt hT2)
      linarith
    exact ‚ü®x_min, x_max‚ü©



  have h_lim_inner : Tendsto (fun (a:‚Ñù) ‚Ü¶ a / 2) (ùìù[>] 0) (ùìù[>] 0) := by
    apply tendsto_nhdsWithin_iff.mpr
    constructor
    ¬∑ have h := (tendsto_id (x := ùìù 0)).div_const (2 : ‚Ñù)
      simp at h
      exact h.mono_left nhdsWithin_le_nhds
    ¬∑ filter_upwards [self_mem_nhdsWithin (s := Ioi 0)] with a ha
      simp at ha
      simp
      exact ha
  have h_final := h_integral.comp h_lim_inner
  exact h_final



lemma integral_sinc_sq_eq_dirichlet_bounded' {a T : ‚Ñù} (ha : 0 < a) (hT : a ‚â§ T) :
   (‚à´ t in a.. T, Real.sinc t)= (‚à´ t in a/2..T/2, (Real.sinc t)^2) -(Real.sinc (a/2))^2 * (a/2) +(Real.sinc (T/2))^2*(T/2):= by
  have h_a_div_2: 0 < a/2:= by linarith
  have h_T_div_2: a/2 ‚â§ T/2:= by linarith
  have h := sinc_bounded_change_interval h_a_div_2 h_T_div_2
  field_simp at h
  rw[‚Üê h]
  have h_new :=
  integral_sinc_sq_eq_dirichlet_bounded h_a_div_2 h_T_div_2


  let f:=  sinc (a / 2) ^ 2 * (a / 2) - sinc (T / 2) ^ 2 * (T / 2)
  let g:=   ‚à´ (t : ‚Ñù) in a / 2..T / 2, Real.sin (2 * t) / t
  have: sinc (a / 2) ^ 2 * (a / 2) - sinc (T / 2) ^ 2 * (T / 2) + ‚à´ (t : ‚Ñù) in a / 2..T / 2, Real.sin (2 * t) / t= f+g:= by
    unfold f g
    field_simp
  rw[this] at h_new
  have h_rewritten : g=(‚à´ (t : ‚Ñù) in a / 2..T / 2, sinc t ^ 2) - f  := by
    rw [h_new]
    ring

  unfold f g at h_rewritten
  rw[h_rewritten]
  ring



lemma integral_sinc_zero_T (T : ‚Ñù)(hT: T>0) :
    (‚à´ t in 0..T, Real.sinc t) = (‚à´ t in 0..T/2,(Real.sinc t)^2) + (Real.sinc (T/2))^2 * (T/2) := by

  let f := fun a ‚Ü¶ ‚à´ t in a..T, Real.sinc t

  let g := fun (a : ‚Ñù) ‚Ü¶ (‚à´ t in a/2..T/2, (Real.sinc t)^2) - (Real.sinc (a/2))^2 * (a/2) + (Real.sinc (T/2))^2 * (T/2)

  have hf : Tendsto f (ùìù[>] 0) (ùìù ((‚à´ t in 0..T, Real.sinc t) )) := limit_sinc_zero T hT

  have hg : Tendsto g (ùìù[>] 0) (ùìù ((‚à´ t in 0..T/2, (Real.sinc t)^2) + (Real.sinc (T/2))^2 * (T/2))) := by
    apply Tendsto.add
    apply Tendsto.sub
    ¬∑ have hflim:= limit_sincsq_zero T hT
      rw [intervalIntegral.integral_of_le] at hflim
      exact hflim
      linarith
    ¬∑ have h_empty : ‚à´ (x : ‚Ñù) in Ioc (T / 2) 0, sinc x ^ 2 = 0 := by
        have h_range : Ioc (T / 2) 0 = ‚àÖ := by
          apply Set.Ioc_eq_empty
          linarith [hT]
        rw [h_range,MeasureTheory.setIntegral_empty]
      rw[h_empty]
      have:= limit_sinc_sq_mul_self_zero
      have h_lim_inner : Tendsto (fun (a:‚Ñù) ‚Ü¶ a / 2) (ùìù[>] 0) (ùìù[>] 0) := by
        apply tendsto_nhdsWithin_iff.mpr
        constructor
        ¬∑ have h := (tendsto_id (x := ùìù 0)).div_const (2 : ‚Ñù)
          simp at h
          exact h.mono_left nhdsWithin_le_nhds
        ¬∑ filter_upwards [self_mem_nhdsWithin (s := Ioi 0)] with a ha
          simp at ha
          simp
          exact ha
      have h_final := this.comp h_lim_inner
      exact h_final
    ¬∑ exact tendsto_const_nhds
  have h_eq : ‚àÄ·∂† a in ùìù[>] 0, f a = g a := by
    have h_mem : Set.Iic T ‚àà ùìù[>] 0 := by
      apply mem_nhdsWithin_of_mem_nhds
      exact Iic_mem_nhds hT
    filter_upwards [self_mem_nhdsWithin, h_mem] with a ha_pos ha_T
    unfold f g
    exact integral_sinc_sq_eq_dirichlet_bounded' ha_pos ha_T
  have hf_lim_from_g : Tendsto f (ùìù[>] 0) (ùìù ((‚à´ (t : ‚Ñù) in 0..T / 2, sinc t ^ 2) + sinc (T / 2) ^ 2 * (T / 2))) := by
    refine (tendsto_congr' ?_).mp hg
    filter_upwards [h_eq] with x hx
    exact hx.symm

  exact tendsto_nhds_unique hf hf_lim_from_g


def sinc_sq_times_exp (t : ‚Ñù) : ‚Ñù ‚Üí ‚Ñù := fun x ‚Ü¶ Real.exp (-x * t) * (Real.sinc t)^2

def neg_sinc_sq_times_id_exp (t : ‚Ñù) : ‚Ñù ‚Üí ‚Ñù := fun x ‚Ü¶ -(Real.sinc t)^2  *t* Real.exp (-x * t)

def sin_sq_times_exp (t : ‚Ñù) : ‚Ñù ‚Üí ‚Ñù := fun x ‚Ü¶ (Real.sin t)^2 * Real.exp (-x * t)

def integral_sinc_sq_times_exp (x: ‚Ñù) : ‚Ñù  := ‚à´ t in Ioi 0 , sinc_sq_times_exp t x

def integral_neg_sinc_sq_times_id_exp (x: ‚Ñù) : ‚Ñù  := ‚à´ t in Ioi 0 , neg_sinc_sq_times_id_exp t x

def integral_sin_sq_times_exp(x: ‚Ñù) : ‚Ñù  := ‚à´ t in Ioi 0 , sin_sq_times_exp t x


lemma hasDeriv_sinc_sq_times_exp(t : ‚Ñù) (ht : 0 < t):
  ‚àÄa: ‚Ñù ,HasDerivAt (sinc_sq_times_exp t) (neg_sinc_sq_times_id_exp t a) a:= by
    unfold sinc_sq_times_exp
    unfold neg_sinc_sq_times_id_exp
    intro a
    have h_inner : HasDerivAt (fun x => -x * t) (-t) a := by
      simpa using hasDerivAt_id a |>.neg |>.mul_const t

    have h_exp : HasDerivAt (fun x => Real.exp (-x * t)) (-t * Real.exp (-a * t)) a := by
      convert h_inner.exp using 1
      ring

    convert h_exp.mul_const ((Real.sinc t)^2) using 1
    unfold sinc
    split_ifs with h_zero
    ¬∑ linarith
    ¬∑ field_simp

lemma hasDeriv_neg_sinc_sq_times_id_exp(t : ‚Ñù) (ht : 0 < t):
  ‚àÄa: ‚Ñù ,HasDerivAt (neg_sinc_sq_times_id_exp t) (sin_sq_times_exp t a) a:= by
    unfold sin_sq_times_exp
    unfold neg_sinc_sq_times_id_exp
    intro a
    have h_inner : HasDerivAt (fun x => -x * t) (-t) a := by
      simpa using hasDerivAt_id a |>.neg |>.mul_const t

    have h_exp : HasDerivAt (fun x => Real.exp (-x * t)) (-t * Real.exp (-a * t)) a := by
      convert h_inner.exp using 1
      ring

    convert h_exp.mul_const (-(Real.sinc t)^2*t) using 1
    unfold sinc
    split_ifs with h_zero
    ¬∑ linarith
    ¬∑ field_simp
    unfold sinc
    have: t‚â† 0:= by linarith
    simp[this]
    field_simp

lemma neg_sinc_sq_times_id_exp_le_exp (t: ‚Ñù):
  ‚àÄ x, ‚Äñneg_sinc_sq_times_id_exp t x‚Äñ ‚â§ Real.exp (-x * t):= by
  intro x
  unfold neg_sinc_sq_times_id_exp
  rw [norm_mul]
  have:  ‚Äñrexp (-x * t)‚Äñ= rexp (-x * t):= by
    simp
  rw[this]
  apply mul_le_of_le_one_left
  have h_exp_pos_le:  0 ‚â§ rexp (-(x * t)):= by
    have h_exp_pos : 0 < Real.exp (-(x * t)) := Real.exp_pos (-(x * t))
    simp[h_exp_pos.le]
  have: rexp (-(x * t))= rexp (-x * t):= by
    simp

  rw[ this] at h_exp_pos_le

  exact h_exp_pos_le
  simp only [norm_neg, norm_eq_abs, norm_mul]
  by_cases h : |t| ‚â§ 1
  ¬∑ have h_sinc : |Real.sinc t| ‚â§ 1 := Real.abs_sinc_le_one t
    have h_sinc2 : |Real.sinc t ^ 2|‚â§ 1 := by
      simp
      exact h_sinc
    have abs_t_val:= abs_nonneg t
    calc |Real.sinc t ^ 2| * |t|
    _ ‚â§ 1 * |t| := by
      apply mul_le_mul_of_nonneg_right  h_sinc2 abs_t_val
    _ ‚â§ 1  := by simp [h]


  ¬∑ have :t‚â† 0:= by
      intro ht_zero
      push_neg at h
      rw [ht_zero, abs_zero] at h
      have: ¬¨((1:‚Ñù)<0) := by linarith
      exact absurd h this
    unfold sinc
    simp[this]
    rw [div_pow, ‚Üê sq_abs (a:= t)]
    field_simp
    have h_sin : |Real.sin t| ‚â§ 1 := Real.abs_sin_le_one t
    have h_sin2 : Real.sin t ^ 2‚â§ 1 := by
      simp
      exact h_sin
    push_neg at h
    exact h_sin2.trans h.le

theorem hasDeriv_integral_sinc_sq_times_exp (x : ‚Ñù) (hx : 0 < x) :
    HasDerivAt (integral_sinc_sq_times_exp) (integral_neg_sinc_sq_times_id_exp x) x := by
  classical

  have h_deriv :‚àÄ t ‚àà Ioi 0,
      HasDerivAt
        (fun x => sinc_sq_times_exp t x)
        (neg_sinc_sq_times_id_exp t x)
        x :=
  by
    intro t ht
    have ht_gt0 : t > 0 := by
      apply mem_Ioi.mp ht
    exact hasDeriv_sinc_sq_times_exp t ht_gt0 x

  have hF_AEmeas : ‚àÄ·∂† x' in nhds x, AEStronglyMeasurable (fun t => sinc_sq_times_exp t x') (volume.restrict (Ioi 0)) := by
    apply Filter.Eventually.of_forall
    intro x'
    unfold sinc_sq_times_exp
    apply ContinuousOn.aestronglyMeasurable
    ¬∑ apply ContinuousOn.mul
      apply Continuous.continuousOn
      have: Continuous (fun x ‚Ü¶ -x' * x):= by
        continuity
      apply Continuous.rexp this
      apply Continuous.continuousOn
      exact Real.continuous_sinc.pow 2
    ¬∑ exact measurableSet_Ioi

  have h_int_sinc_sq := integrable_sinc_sq

  have hF_int : Integrable (fun t => sinc_sq_times_exp t x) (volume.restrict (Ioi 0)) :=by
    apply MeasureTheory.Integrable.mono h_int_sinc_sq
    ¬∑ exact hF_AEmeas.self_of_nhds
    ¬∑ rw [ae_restrict_iff' measurableSet_Ioi]
      refine Filter.Eventually.of_forall (fun t ht_mem => ?_)
      unfold sinc_sq_times_exp
      simp only [neg_mul, norm_eq_abs, abs_mul]
      simp
      apply mul_le_of_le_one_left (pow_two_nonneg _)

      have ht_pos : 0 < t := by
        rw [mem_Ioi] at ht_mem
        exact ht_mem

      have : rexp (-(x * t))‚â§ 1:= by
        simp[ht_pos]
        exact hx.le
      exact this

  have hF'_meas : MeasureTheory.AEStronglyMeasurable (fun t => neg_sinc_sq_times_id_exp t x) (volume.restrict (Ioi 0)) := by
    unfold neg_sinc_sq_times_id_exp
    apply ContinuousOn.aestronglyMeasurable
    ¬∑ apply ContinuousOn.mul
      apply Continuous.continuousOn
      apply Continuous.mul
      apply Continuous.neg
      exact continuous_sinc.pow 2
      continuity
      apply Continuous.continuousOn
      have: Continuous (fun x' ‚Ü¶ -x * x'):= by
        continuity
      apply Continuous.rexp this
    ¬∑ exact measurableSet_Ioi

  let r := x / 2
  have hr : r > 0 := by
    unfold r
    simp[hx]

  let bound_func := fun t => Real.exp (-r * t)

  have h_bound : ‚àÄ·µê t ‚àÇvolume.restrict (Ioi 0), ‚àÄ x' ‚àà Metric.ball x r,
      ‚Äñneg_sinc_sq_times_id_exp t x'‚Äñ ‚â§ bound_func t := by
    rw [ae_restrict_iff' measurableSet_Ioi]
    refine Filter.Eventually.of_forall (fun t ht_mem x' hx' => ?_)
    have ht_pos : 0 < t := by
      rw[mem_Ioi] at ht_mem
      exact ht_mem
    unfold bound_func
    have  first_ineq: ‚Äñ neg_sinc_sq_times_id_exp t x'‚Äñ‚â§ rexp (-x' * t) := by
      exact neg_sinc_sq_times_id_exp_le_exp t x'
    have second_ineq : rexp (-x' * t) ‚â§ rexp (-r * t):= by
      apply Real.exp_le_exp.mpr
      apply mul_le_mul_of_nonneg_right
      rw [Metric.mem_ball, Real.dist_eq] at hx'
      have h_ineg_rx'x :  -r < x' - x := (abs_lt.mp hx').1
      have: x-r < x':= by
        linarith [h_ineg_rx'x]
      have h_r_x_2 : x-r=r := by
        unfold r
        ring_nf
      rw[h_r_x_2] at this
      have h_res: -x' < -r := by
        linarith
      exact h_res.le
      exact ht_pos.le
    exact le_trans first_ineq second_ineq
  have h_bound_int : Integrable bound_func (volume.restrict (Ioi 0)) := by
    apply (integrableOn_exp_mul_Ioi (by linarith) 0).integrable

  have h_diff : ‚àÄ·µê t ‚àÇvolume.restrict (Ioi 0), ‚àÄ x' ‚àà Metric.ball x r,
      HasDerivAt (fun x_param => sinc_sq_times_exp t x_param) (neg_sinc_sq_times_id_exp t x') x' := by
    rw [ae_restrict_iff' measurableSet_Ioi]
    refine Filter.Eventually.of_forall (fun t ht_mem x' _ => ?_)
    have ht_pos : 0 < t := by
      rw[mem_Ioi] at ht_mem
      exact ht_mem
    exact hasDeriv_sinc_sq_times_exp t ht_pos x'

  have h_final := hasDerivAt_integral_of_dominated_loc_of_deriv_le
    hr hF_AEmeas hF_int hF'_meas h_bound h_bound_int h_diff

  unfold integral_sinc_sq_times_exp integral_neg_sinc_sq_times_id_exp
  exact h_final.2

theorem hasDeriv_integral_neg_sinc_sq_times_id_exp (x : ‚Ñù) (hx : 0 < x) :
    HasDerivAt (integral_neg_sinc_sq_times_id_exp) (integral_sin_sq_times_exp x) x := by
  classical

  have h_deriv :‚àÄ t ‚àà Ioi 0,
      HasDerivAt
        (fun x => neg_sinc_sq_times_id_exp t x)
        (sin_sq_times_exp t x)
        x :=
  by
    intro t ht
    have ht_gt0 : t > 0 := by
      apply mem_Ioi.mp ht

    exact hasDeriv_neg_sinc_sq_times_id_exp t ht_gt0 x


  have hF_AEmeas : ‚àÄ·∂† x' in nhds x, AEStronglyMeasurable (fun t => neg_sinc_sq_times_id_exp t x') (volume.restrict (Ioi 0)) := by
    apply Filter.Eventually.of_forall
    intro x'
    unfold neg_sinc_sq_times_id_exp
    apply ContinuousOn.aestronglyMeasurable
    ¬∑ apply ContinuousOn.mul
      apply Continuous.continuousOn
      apply Continuous.mul
      apply Continuous.neg
      exact Real.continuous_sinc.pow 2
      continuity
      have: Continuous (fun x ‚Ü¶ -x' * x):= by
        continuity
      apply Continuous.continuousOn
      apply Continuous.rexp this
    ¬∑ exact measurableSet_Ioi

  have h_int_x :
    IntegrableOn (fun t => Real.exp (-x * t)) (Ioi 0) volume :=
  by
    have h_neg : -x < 0 := by linarith [hx]
    exact integrableOn_exp_mul_Ioi h_neg 0

  have hF_int : Integrable (fun t => neg_sinc_sq_times_id_exp  t x) (volume.restrict (Ioi 0)) :=by
    apply MeasureTheory.Integrable.mono h_int_x
    ¬∑ exact hF_AEmeas.self_of_nhds
    ¬∑ rw [ae_restrict_iff' measurableSet_Ioi]
      refine Filter.Eventually.of_forall (fun t ht_mem => ?_)
      have ht_pos : 0 < t := by
        rw [mem_Ioi] at ht_mem
        exact ht_mem
      have : ‚Äñrexp (-x * t)‚Äñ= rexp (-x * t):= by
        simp only [neg_mul, norm_eq_abs, abs_exp]
      rw[this]

      exact neg_sinc_sq_times_id_exp_le_exp t x

  have hF'_meas : MeasureTheory.AEStronglyMeasurable (fun t => sin_sq_times_exp t x) (volume.restrict (Ioi 0)) := by
    unfold sin_sq_times_exp
    apply ContinuousOn.aestronglyMeasurable
    ¬∑ apply ContinuousOn.mul
      apply Continuous.continuousOn
      exact continuous_sin.pow 2
      apply Continuous.continuousOn
      have: Continuous (fun x' ‚Ü¶ -x * x'):= by
        continuity
      apply Continuous.rexp this
    ¬∑ exact measurableSet_Ioi

  let r := x / 2
  have hr : r > 0 := by
    unfold r
    simp[hx]

  let bound_func := fun t => Real.exp (-r * t)

  have h_bound : ‚àÄ·µê t ‚àÇvolume.restrict (Ioi 0), ‚àÄ x' ‚àà Metric.ball x r,
      ‚Äñsin_sq_times_exp t x'‚Äñ ‚â§ bound_func t := by
    rw [ae_restrict_iff' measurableSet_Ioi]
    refine Filter.Eventually.of_forall (fun t ht_mem x' hx' => ?_)
    have ht_pos : 0 < t := by
      rw[mem_Ioi] at ht_mem
      exact ht_mem
    unfold bound_func
    have  first_ineq: ‚Äñ sin_sq_times_exp t x'‚Äñ‚â§ rexp (-x' * t) := by
      exact sin_sq_times_exp_le_exp t x'
    have second_ineq : rexp (-x' * t) ‚â§ rexp (-r * t):= by
      apply Real.exp_le_exp.mpr
      apply mul_le_mul_of_nonneg_right
      rw [Metric.mem_ball, Real.dist_eq] at hx'
      have h_ineg_rx'x :  -r < x' - x := (abs_lt.mp hx').1
      have: x-r < x':= by
        linarith [h_ineg_rx'x]
      have h_r_x_2 : x-r=r := by
        unfold r
        ring_nf
      rw[h_r_x_2] at this
      have h_res: -x' < -r := by
        linarith
      exact h_res.le
      exact ht_pos.le
    exact le_trans first_ineq second_ineq
  have h_bound_int : Integrable bound_func (volume.restrict (Ioi 0)) := by
    apply (integrableOn_exp_mul_Ioi (by linarith) 0).integrable

  have h_diff : ‚àÄ·µê t ‚àÇvolume.restrict (Ioi 0), ‚àÄ x' ‚àà Metric.ball x r,
      HasDerivAt (fun x_param => neg_sinc_sq_times_id_exp t x_param) (sin_sq_times_exp t x') x' := by
    rw [ae_restrict_iff' measurableSet_Ioi]
    refine Filter.Eventually.of_forall (fun t ht_mem x' _ => ?_)
    have ht_pos : 0 < t := by
      rw[mem_Ioi] at ht_mem
      exact ht_mem
    exact hasDeriv_neg_sinc_sq_times_id_exp t ht_pos x'

  have h_final := hasDerivAt_integral_of_dominated_loc_of_deriv_le
    hr hF_AEmeas hF_int hF'_meas h_bound h_bound_int h_diff

  unfold integral_sin_sq_times_exp integral_neg_sinc_sq_times_id_exp
  exact h_final.2


lemma integrable_cexp_mul_Ioi_of_re_neg {z : ‚ÑÇ} (hz : z.re < 0) (Œµ : ‚Ñù) :
    Integrable (fun (t : ‚Ñù) => cexp (‚Üët * z)) (volume.restrict (Ioi Œµ)) := by
  rw [‚Üê integrable_norm_iff]
  simp_rw [Complex.norm_exp]
  have : (fun t:‚Ñù ‚Ü¶ (rexp ((‚Üët * z).re))) = (fun (t:‚Ñù) ‚Ü¶ rexp ( (z.re) * t)) := by
    funext t
    rw [Complex.mul_re, Complex.ofReal_re, Complex.ofReal_im, zero_mul, sub_zero, mul_comm]

  rw [this]
  exact integrableOn_exp_mul_Ioi hz Œµ
  -- Mesurabilit√©
  apply Continuous.aestronglyMeasurable
  continuity

lemma add_integral_integrable(Œµ : ‚Ñù)(x : ‚Ñù) (hx : 0 < x)  :
 ‚à´ t in Ioi Œµ, (cexp (-‚Üët*(2*I + x))+ cexp ( ‚Üët*(2*I -x )) -2*cexp (- ‚Üët*x))=
 (‚à´ t in Ioi Œµ, cexp (-‚Üët*(2*I + x)))+ (‚à´ t in Ioi Œµ,cexp ( ‚Üët*(2*I -x ))) -‚à´ t in Ioi Œµ,(2*cexp (- ‚Üët*x)):= by
  have h_int1 : Integrable (fun t ‚Ü¶ cexp (‚Üët * (-2 * I - x))) (volume.restrict (Ioi Œµ)) := by
    apply integrable_cexp_mul_Ioi_of_re_neg
    simp [hx]
  have h_int2 : Integrable (fun t ‚Ü¶ cexp (‚Üët * (2 * I - x))) (volume.restrict (Ioi Œµ)) := by
    apply integrable_cexp_mul_Ioi_of_re_neg
    simp [hx]
  have h_int3 : Integrable (fun t:‚Ñù ‚Ü¶ (2 : ‚ÑÇ) * cexp (‚Üët * (-x))) (volume.restrict (Ioi Œµ)) := by
    apply Integrable.const_mul
    apply integrable_cexp_mul_Ioi_of_re_neg
    simp [hx]
  have h_rew : ‚àÄ t, -‚Üët * (2 * I + x) = ‚Üët * (-2 * I - x) := fun t ‚Ü¶ by ring
  simp_rw [h_rew]
  rw [integral_sub, integral_add]
  ¬∑ exact h_int1
  ¬∑ exact h_int2
  ¬∑ exact h_int1.add h_int2
  ¬∑ have : (fun t:‚Ñù ‚Ü¶ 2 * cexp (-‚Üët * ‚Üëx))=fun t:‚Ñù ‚Ü¶ 2 * cexp (‚Üët * (-‚Üëx)):= by
      ext t
      ring_nf
    rw[this]
    exact h_int3

theorem compute_deriv_integral_sin_div_times_exp_eps(Œµ : ‚Ñù)(x : ‚Ñù) (hx : 0 < x) :
 ‚à´ t in Ioi Œµ, (Real.sin t)^2 * Real.exp (-x * t)=rexp (- x* Œµ)*((Real.sin (2 * Œµ)- (x/2) * Real.cos (2 * Œµ)) / (4 + x^2)+ 1 / (2 * x)) :=by
  apply (Complex.ofReal_inj).mp

  calc  ‚Üë(‚à´ (t : ‚Ñù) in Ioi Œµ, (Real.sin t)^2 * rexp (-x * t))
    _ =  ‚à´ t in Ioi Œµ, ((Real.sin t)^2* rexp (-x * t) : ‚ÑÇ) := by
      simp[‚Üêintegral_complex_ofReal]
    _= ‚à´ t in Ioi Œµ, (Real.sin t:‚ÑÇ)^2 * (rexp (-x * t) : ‚ÑÇ):= by
      congr
    _= ‚à´ t in Ioi Œµ, (Real.sin t:‚ÑÇ)^2 * cexp (-x * ‚Üët) := by
      congr
      simp
    _ = ‚à´ t in Ioi Œµ, ((cexp (-I * ‚Üët) - cexp (I * ‚Üët)) / (2 * I))^2 * cexp (-x * ‚Üët):= by
      congr
      funext t
      simp
      have h_sin : Complex.sin t = (Complex.exp (-t * I) - Complex.exp (t * I)) * I / 2 := by
        rw [‚Üê Complex.two_sin]
        simp
      simp_rw [h_sin]
      field_simp [I_ne_zero]
      simp
    _=‚à´ t in Ioi Œµ, (cexp (-I * ‚Üët) - cexp (I * ‚Üët))^2 / (2 * I)^2 * cexp (-x * ‚Üët):= by
      congr
      funext t
      field_simp
    _= ‚à´ t in Ioi Œµ, (cexp (-I * ‚Üët)^2 -2*cexp (-I * ‚Üët)*cexp (I * ‚Üët)+ cexp (I * ‚Üët)^2) / (2 * I)^2 * cexp (-x * ‚Üët):= by
      congr
      funext t
      ring_nf
     _= ‚à´ t in Ioi Œµ, (cexp (-2*I * ‚Üët) -2+ cexp (2*I * ‚Üët)) / (2 * I)^2 * cexp (-x * ‚Üët):= by
      congr
      funext t
      have: cexp (-I * ‚Üët) ^ 2 =  cexp (-2*I * ‚Üët):= by
        rw [‚Üê Complex.exp_nat_mul]
        ring_nf
      rw[this]
      have: cexp (I * ‚Üët) ^ 2 =  cexp (2*I * ‚Üët):= by
        rw [‚Üê Complex.exp_nat_mul]
        ring_nf
      rw[this]
      have: 2*cexp (-I * ‚Üët)*cexp (I * ‚Üët)= 2:= by
        field_simp
        rw [‚Üê Complex.exp_add (-(I * ‚Üët)) (I * ‚Üët)]
        ring_nf
        exact Complex.exp_zero
      rw[this]
    _= -‚à´ t in Ioi Œµ, (cexp (-2*I * ‚Üët) -2+ cexp (2*I * ‚Üët)) / 4  * cexp (-x * ‚Üët):= by
      rw [‚Üê integral_neg]
      congr
      funext t
      field_simp
      rw [I_sq]
      ring_nf
    _= -‚à´ t in Ioi Œµ, (cexp (-2*I * ‚Üët -x * ‚Üët) -2*cexp (-x * ‚Üët) + cexp (2*I * ‚Üët-x * ‚Üët)) / 4  := by
      congr
      funext t
      field_simp
      rw [sub_add_eq_add_sub, sub_mul,add_mul]

      have: cexp (-(2 * I * ‚Üët)) * cexp (-(‚Üët * ‚Üëx)) =  cexp (‚Üët * (-(2 * I) - ‚Üëx)):= by
        rw [‚Üê Complex.exp_add (-(2 * I * ‚Üët)) (-(‚Üët * ‚Üëx))]
        ring_nf
      rw[this]

      have: cexp ((2 * I * ‚Üët)) * cexp (-(‚Üët * ‚Üëx)) =  cexp (‚Üët * (2 * I - ‚Üëx)):= by
        rw [‚Üê Complex.exp_add ((2 * I * ‚Üët)) (-(‚Üët * ‚Üëx))]
        ring_nf
      rw[this]
      ring_nf
     _= -‚à´ t in Ioi Œµ, (cexp (-‚Üët*(2*I + x))+ cexp ( ‚Üët*(2*I -x )) -2*cexp (- ‚Üët*x) ) / 4  := by
      congr
      funext t
      field_simp
      have: cexp (‚Üët * (-(2 * I) - ‚Üëx)) =   cexp (-(‚Üët * (2 * I + ‚Üëx))) := by
        ring_nf
      rw[this]
      ring_nf

    _= -‚à´ t in Ioi Œµ,1/4* (cexp (-‚Üët*(2*I + x))+ cexp ( ‚Üët*(2*I -x )) -2*cexp (- ‚Üët*x) ) := by
      congr
      funext t
      field_simp
    _= -1/4*(‚à´ t in Ioi Œµ, cexp (-‚Üët*(2*I + x))+ cexp ( ‚Üët*(2*I -x )) -2*cexp (- ‚Üët*x) ) := by
      simp_rw [div_eq_mul_inv]
      simp
      rw [integral_mul_left ( 4‚Åª¬π )]
    _= -1/4*((‚à´ t in Ioi Œµ, cexp (-‚Üët*(2*I + x)))+ (‚à´ t in Ioi Œµ,cexp ( ‚Üët*(2*I -x ))) -(‚à´ t in Ioi Œµ,2*cexp (- ‚Üët*x)) ) := by
      rw[ add_integral_integrable Œµ x hx]
    _=-1/4*((cexp ( -(2*I + x)*‚ÜëŒµ) / (2*I + x))+ (‚à´ t in Ioi Œµ,cexp ( ‚Üët*(2*I -x ))) -(‚à´ t in Ioi Œµ,2*cexp (- ‚Üët*x)) ) := by
      let a := -(2*I + x)
      have h_re : a.re < 0 := by
        unfold a
        simp [I_re, ofReal_re]
        exact hx
      have h_int_val : ‚à´ (t : ‚Ñù) in Ioi Œµ, cexp (‚Üët*a) = - cexp (a*‚ÜëŒµ) / a := by
        have :‚à´ (t : ‚Ñù) in Ioi Œµ, cexp (‚Üët*a) = ‚à´ (t : ‚Ñù) in Ioi Œµ, cexp (a*‚Üët):= by
          congr
          funext t
          field_simp
        rw[this]
        apply  integral_exp_mul_complex_Ioi h_re Œµ

      have: ‚àÄt: ‚Ñù , cexp (‚Üët * a) = cexp (-‚Üët*(2*I + x)) := by
        unfold a
        intro t
        ring_nf
      simp_rw[this] at h_int_val
      rw[h_int_val]
      unfold a
      simp
      field_simp
      have h_in : -‚Üëx + -(2 * I) = -(2 * I+‚Üëx ) := by ring
      rw[h_in]
      field_simp


    _=-1/4*((cexp ( -(2*I + x)*‚ÜëŒµ) / (2*I + x))+ (-cexp ((2 * I - ‚Üëx) * ‚ÜëŒµ) / (2 * I - ‚Üëx)) -(‚à´ t in Ioi Œµ,2*cexp (- ‚Üët*x)) ) := by
      let a := 2*I -x
      have h_re : a.re < 0 := by
        unfold a
        simp [I_re, ofReal_re]
        exact hx
      have h_int_val : ‚à´ (t : ‚Ñù) in Ioi Œµ, cexp (‚Üët*a) = - cexp (a*‚ÜëŒµ) / a := by
        have :‚à´ (t : ‚Ñù) in Ioi Œµ, cexp (‚Üët*a) = ‚à´ (t : ‚Ñù) in Ioi Œµ, cexp (a*‚Üët):= by
          congr
          funext t
          field_simp
        rw[this]
        apply  integral_exp_mul_complex_Ioi h_re Œµ
      unfold a at h_int_val
      rw[h_int_val]

    _=-1/4*((cexp ( -(2*I + x)*‚ÜëŒµ) / (2*I + x))+ (-cexp ((2 * I - ‚Üëx) * ‚ÜëŒµ) / (2 * I - ‚Üëx)) +(2* cexp (‚Üë(-x) * ‚ÜëŒµ) / ‚Üë(-x)) ) := by
      let a:‚ÑÇ := ‚Üë(-x)

      have h_re : a.re < 0 := by
        unfold a
        simp [I_re, ofReal_re]
        exact hx
      have h_int_val : ‚à´ (t : ‚Ñù) in Ioi Œµ,2* cexp (‚Üët*a) = - 2*cexp (a*‚ÜëŒµ) / a := by
        have :‚à´ (t : ‚Ñù) in Ioi Œµ, 2* cexp (‚Üët*a) = 2*‚à´ (t : ‚Ñù) in Ioi Œµ, cexp (a*‚Üët):= by
          rw[integral_mul_left 2]
          congr
          funext t
          field_simp
        rw[this]
        rw[integral_exp_mul_complex_Ioi h_re Œµ]
        ring_nf
      have: ‚àÄt: ‚Ñù , cexp (‚Üët * a) = cexp (-‚Üët*x) := by
        intro t
        unfold a
        push_cast
        ring_nf
      simp_rw[this] at h_int_val
      unfold a at h_int_val
      rw[h_int_val]
      have:  - -2 * cexp (‚Üë(-x) * ‚ÜëŒµ) / ‚Üë(-x)= 2 * cexp (‚Üë(-x) * ‚ÜëŒµ) / ‚Üë(-x):= by
        ring
      congr 2
      ring

    _=-1/4*((cexp ( -(2*I + x)*‚ÜëŒµ) *(2 * I - ‚Üëx) / ((2*I + x)*(2 * I - ‚Üëx)))+ (-cexp ((2 * I - ‚Üëx) * ‚ÜëŒµ) / (2 * I - ‚Üëx)) +(2* cexp (‚Üë(-x) * ‚ÜëŒµ) / ‚Üë(-x)) ) := by
      congr 2
      have h1 : 2 * I - ‚Üëx ‚â† 0 := by
        intro h
        have h_re := congr_arg Complex.re h
        simp at h_re
        exact hx.ne' h_re
      field_simp

    _=-1/4*((cexp ( -(2*I + x)*‚ÜëŒµ) *(2 * I - ‚Üëx) / ((2*I + x)*(2 * I - ‚Üëx)))+ (-cexp ((2 * I - ‚Üëx) * ‚ÜëŒµ) *(2*I + x)/ ((2*I + x)*(2 * I - ‚Üëx))) +(2* cexp (‚Üë(-x) * ‚ÜëŒµ) / ‚Üë(-x)) ) := by
      congr 2
      have h1 : 2*I + x ‚â† 0 := by
        intro h
        have h_re := congr_arg Complex.re h
        simp at h_re
        exact hx.ne' h_re
      field_simp
    _=-1/4*((cexp ( -(2*I + x)*‚ÜëŒµ) *(2 * I - ‚Üëx) -cexp ((2 * I - ‚Üëx) * ‚ÜëŒµ) *(2*I + x))/ ((2*I + x)*(2 * I - ‚Üëx)) +(2* cexp (‚Üë(-x) * ‚ÜëŒµ) / ‚Üë(-x)) ) := by
      congr 2
      ring

    _=-1/4*(-(cexp ( -(2*I + x)*‚ÜëŒµ) *(2 * I - ‚Üëx) -cexp ((2 * I - ‚Üëx) * ‚ÜëŒµ) *(2*I + x))/ (4 + x^2) +(2* cexp (‚Üë(-x) * ‚ÜëŒµ) / ‚Üë(-x)) ) := by
      congr 2
      have h_denom : (2*I + x)*(2 * I - ‚Üëx) = -(4 + ‚Üëx^2) := by
        ring_nf
        simp only [I_sq]
        ring_nf
      rw [h_denom]
      field_simp
     _=-1/4 * ( ((cexp (2*I*‚ÜëŒµ) - cexp (-2*I*‚ÜëŒµ)) * 2*I * cexp (-‚Üëx*‚ÜëŒµ) + (cexp (2*I*‚ÜëŒµ) + cexp (-2*I*‚ÜëŒµ)) * x * cexp (-‚Üëx*‚ÜëŒµ)) / (4 + x^2) + (2 * cexp (-‚Üëx*‚ÜëŒµ) / -‚Üëx) ) := by
      congr 2
      field_simp
      have: cexp (-((2 * I + ‚Üëx) * ‚ÜëŒµ))= cexp (-2 * I *‚ÜëŒµ) *cexp (-‚Üëx* ‚ÜëŒµ):= by
        ring_nf
        rw [exp_sub (-(I * ‚ÜëŒµ * 2)) (‚Üëx * ‚ÜëŒµ)]
        field_simp
        rw [‚Üê Complex.exp_add]
        ring_nf
        simp[Complex.exp_zero]
      rw[this]
      have: cexp (‚ÜëŒµ * (2 * I - ‚Üëx)) = cexp (‚ÜëŒµ *2 * I) * cexp (-‚Üëx* ‚ÜëŒµ):= by
        ring_nf
        rw [exp_sub (‚ÜëŒµ* I * 2) (‚ÜëŒµ*‚Üëx)]
        field_simp
        rw [‚Üê Complex.exp_add]
        ring_nf
        simp[Complex.exp_zero]
      rw[this]
      field_simp
      ring_nf
      calc 2 * cexp (‚Üë(-x) * ‚ÜëŒµ) / ‚Üë(-x)
      _= 2 * cexp ((-‚Üëx) * ‚ÜëŒµ) / (-‚Üëx) := by
        rw[Complex.ofReal_neg]
      _ = 2 * cexp (-(‚Üëx * ‚ÜëŒµ)) / (-‚Üëx) := by
        ring
      _ = 2 * cexp (-‚Üëx * ‚ÜëŒµ) / -‚Üëx    := by
        ring
    _= -cexp (-‚Üëx * ‚ÜëŒµ) / 4 * ( (2 * I * (cexp (2 * I * ‚ÜëŒµ) - cexp (-2 * I * ‚ÜëŒµ)) + x * (cexp (2 * I * ‚ÜëŒµ) + cexp (-2 * I * ‚ÜëŒµ))) / (4 + x^2) - 2 / x ) := by
      ring_nf
    _= -cexp (-‚Üëx * ‚ÜëŒµ) / 4 * ( (2 * I * (2 * I * Complex.sin (2 * Œµ)) + x * (2 * Complex.cos (2 * Œµ))) / (4 + x^2) - 2 / x ) := by
      have: cexp (2 * I * ‚ÜëŒµ) - cexp (-2 * I * ‚ÜëŒµ)= 2 * I*Complex.sin (2  * ‚ÜëŒµ):= by
        unfold Complex.sin
        ring
        rw[I_sq]
        ring
      rw[this]
      have: cexp (2 * I * ‚ÜëŒµ) + cexp (-2 * I * ‚ÜëŒµ)= 2 * Complex.cos (2 * ‚ÜëŒµ):= by
        unfold Complex.cos
        field_simp
      rw[this]
    _= -cexp (-‚Üëx * ‚ÜëŒµ) * ( (-Complex.sin (2 * Œµ) + (x/2) * Complex.cos (2 * Œµ)) / (4 + x^2) - 1 / (2 * x) ) := by
      ring_nf
      rw[I_sq]
      ring_nf
    _=-rexp (- x* Œµ)* ( (-Complex.sin (2 * Œµ) + (x/2) * Complex.cos (2 * Œµ)) / (4 + x^2) - 1 / (2 * x) ) := by
      have : cexp (- ‚Üëx* ‚ÜëŒµ)= cexp (‚Üë(- x* Œµ)):= by
        push_cast
        simp
      rw[this]
      rw[Complex.ofReal_exp]
    _=-rexp (- x* Œµ)* ( (-‚Üë(Real.sin (2 * Œµ)) + (x/2) * ‚Üë(Real.cos (2 * Œµ))) / (4 + x^2) - 1 / (2 * x) ) := by
      rw[Complex.ofReal_cos]
      rw[Complex.ofReal_sin]
      push_cast
      field_simp
    _=-rexp (- x* Œµ)* (‚Üë(-(Real.sin (2 * Œµ)) + (x/2) * (Real.cos (2 * Œµ))) / (‚Üë( (4:‚Ñù) + x^2))- ‚Üë(1 / (2 * x))):= by
      push_cast
      field_simp
    _=-rexp (- x* Œµ)* (‚Üë((-Real.sin (2 * Œµ)+ (x/(2:‚Ñù)) * Real.cos (2 * Œµ)) / ((4:‚Ñù) + x^2))- ‚Üë(1 / (2 * x))):= by
      push_cast
      field_simp
    _=-rexp (- x* Œµ)* ‚Üë(((-Real.sin (2 * Œµ)+ (x/(2:‚Ñù)) * Real.cos (2 * Œµ)) / ((4:‚Ñù) + x^2))- (1:‚Ñù) / ((2:‚Ñù) * x)):= by
      push_cast
      field_simp
    _=‚Üë(-rexp (- x* Œµ)*((-Real.sin (2 * Œµ)+ (x/(2:‚Ñù)) * Real.cos (2 * Œµ)) / ((4:‚Ñù) + x^2)- (1:‚Ñù) / ((2:‚Ñù) * x))):= by
      push_cast
      field_simp
    _=‚Üë(rexp (- x* Œµ)*((Real.sin (2 * Œµ)- (x/(2:‚Ñù)) * Real.cos (2 * Œµ)) / ((4:‚Ñù) + x^2)+ (1:‚Ñù) / ((2:‚Ñù) * x))):= by
      push_cast
      field_simp
      ring_nf


theorem hasDeriv_integral_neg_sinc_sq_times_id_exp' (x : ‚Ñù) (hx : 0 < x) : HasDerivAt (integral_neg_sinc_sq_times_id_exp) (-(1/2) * x / (4 + x^2)+ 1 / (2 * x)) x:= by
  have h_deriv: HasDerivAt (integral_neg_sinc_sq_times_id_exp) (integral_sin_sq_times_exp x) x := by
    exact hasDeriv_integral_neg_sinc_sq_times_id_exp x hx
  unfold integral_sin_sq_times_exp at h_deriv
  unfold sin_sq_times_exp at h_deriv
  simp_rw[compute_deriv_integral_sin_div_times_exp_eps 0 x hx] at h_deriv
  simp at h_deriv
  have:-(x / 2) / (4 + x ^ 2) + x‚Åª¬π * 2‚Åª¬π= -(1/2) * x / (4 + x^2)+ 1 / (2 * x):= by
    field_simp
  rw[this] at h_deriv
  exact h_deriv


lemma tendsto_integral_neg_sinc_sq_times_id_exp :
    Tendsto (integral_neg_sinc_sq_times_id_exp) atTop (ùìù 0) := by
  classical
  unfold integral_neg_sinc_sq_times_id_exp  neg_sinc_sq_times_id_exp
  rw [tendsto_zero_iff_norm_tendsto_zero]
  let f := fun x : ‚Ñù ‚Ü¶ ‚Äñ‚à´ (t : ‚Ñù) in Ioi 0, -sinc t ^ 2 * t * rexp (-x * t)‚Äñ
  let g : ‚Ñù ‚Üí ‚Ñù := fun _ ‚Ü¶ 0
  let h := fun x : ‚Ñù ‚Ü¶ 1 / x
  apply tendsto_of_tendsto_of_tendsto_of_le_of_le' (g := g) (h := h)
  ¬∑ exact tendsto_const_nhds
  ¬∑ unfold h
    simp_rw[one_div]
    exact tendsto_inv_atTop_zero
  ¬∑ exact Eventually.of_forall (fun x ‚Ü¶ norm_nonneg _)
  ¬∑ filter_upwards [eventually_gt_atTop 0] with x hx_pos
    dsimp [f, h]
    have h_int_exp : ‚à´ t in Ioi 0, rexp (-x * t) = 1 / x := by
      rw [integral_exp_mul_Ioi (neg_neg_of_pos hx_pos) 0]
      simp [ mul_zero, Real.exp_zero]
    rw [‚Üê h_int_exp]
    rw [‚Üê Real.norm_eq_abs]
    apply norm_integral_le_of_norm_le
    ¬∑ have h_neq : ‚à´ (t : ‚Ñù) in Ioi 0, rexp (-x * t) ‚â† 0 := by
        rw [h_int_exp]
        exact one_div_ne_zero (ne_of_gt hx_pos)

      apply MeasureTheory.Integrable.of_integral_ne_zero
      exact h_neq

    ¬∑ filter_upwards [self_mem_ae_restrict (measurableSet_Ioi : MeasurableSet (Ioi (0:‚Ñù)))] with t ht
      have ht_pos : 0 < t := mem_Ioi.mp ht
      rw [norm_mul, norm_eq_abs (rexp _), abs_exp]
      field_simp
      rw [norm_eq_abs]
      simp[Real.abs_sinc_le_one]
      by_cases h : |t| ‚â§ 1
      ¬∑ have h_sinc : |Real.sinc t| ‚â§ 1 := Real.abs_sinc_le_one t
        have h_sinc2 : Real.sinc t ^ 2‚â§ 1 := by
          simp
          exact h_sinc
        have abs_t_val:= abs_nonneg t
        calc Real.sinc t ^ 2* |t|
          _ ‚â§ 1 * |t| := by
            apply mul_le_mul_of_nonneg_right  h_sinc2 abs_t_val
          _ ‚â§ 1  := by simp [h]
      ¬∑ have :t‚â† 0:= by
          intro ht_zero
          push_neg at h
          rw [ht_zero, abs_zero] at h
          have: ¬¨((1:‚Ñù)<0) := by linarith
          exact absurd h this
        unfold sinc
        simp[this]
        rw [div_pow, ‚Üê sq_abs (a:= t)]
        field_simp
        have h_sin : |Real.sin t| ‚â§ 1 := Real.abs_sin_le_one t
        have h_sin2 : Real.sin t ^ 2‚â§ 1 := by
          simp
          exact h_sin
        push_neg at h
        exact h_sin2.trans h.le

lemma tendsto_integral_sinc_sq_times_exp :
    Tendsto (integral_sinc_sq_times_exp) atTop (ùìù 0) := by
  classical
  unfold integral_sinc_sq_times_exp  sinc_sq_times_exp
  rw [tendsto_zero_iff_norm_tendsto_zero]
  let f := fun x : ‚Ñù ‚Ü¶ ‚Äñ‚à´ (t : ‚Ñù) in Ioi 0, rexp (-x * t) * sinc t ^ 2‚Äñ
  let g : ‚Ñù ‚Üí ‚Ñù := fun _ ‚Ü¶ 0
  let h := fun x : ‚Ñù ‚Ü¶ 1 / x
  apply tendsto_of_tendsto_of_tendsto_of_le_of_le' (g := g) (h := h)
  ¬∑ exact tendsto_const_nhds
  ¬∑ unfold h
    simp_rw[one_div]
    exact tendsto_inv_atTop_zero
  ¬∑ exact Eventually.of_forall (fun x ‚Ü¶ norm_nonneg _)
  ¬∑ filter_upwards [eventually_gt_atTop 0] with x hx_pos
    dsimp [f, h]
    have h_int_exp : ‚à´ t in Ioi 0, rexp (-x * t) = 1 / x := by
      rw [integral_exp_mul_Ioi (neg_neg_of_pos hx_pos) 0]
      simp [ mul_zero, Real.exp_zero]
    rw [‚Üê h_int_exp]
    rw [‚Üê Real.norm_eq_abs]
    apply norm_integral_le_of_norm_le
    ¬∑ have h_neq : ‚à´ (t : ‚Ñù) in Ioi 0, rexp (-x * t) ‚â† 0 := by
        rw [h_int_exp]
        exact one_div_ne_zero (ne_of_gt hx_pos)

      apply MeasureTheory.Integrable.of_integral_ne_zero
      exact h_neq

    ¬∑ filter_upwards [self_mem_ae_restrict (measurableSet_Ioi : MeasurableSet (Ioi (0:‚Ñù)))] with t ht
      have ht_pos : 0 < t := mem_Ioi.mp ht
      rw [norm_mul, norm_eq_abs (rexp _), abs_exp]
      field_simp
      rw [norm_eq_abs]
      simp[Real.abs_sinc_le_one]

theorem integral_neg_sinc_sq_times_id_exp_eq (x : ‚Ñù) (hx : 0 < x) :
    integral_neg_sinc_sq_times_id_exp x = 1/4*Real.log (x^2/(4+x^2)) := by
    let G := fun t => 1/4* Real.log (t^2/(4+t^2))
    let H := fun t => integral_neg_sinc_sq_times_id_exp t - G t
    have G_diff:  ‚àÄ y >0 , HasDerivAt G (-(1/2) * y / (4 + y^2)+ 1 / (2 * y)) y := by
      intro y hy

      have hg : HasDerivAt G (-(1/2) * y / (4 + y^2) + 1 / (2 * y)) y := by
        let f := fun t : ‚Ñù ‚Ü¶ t^2 / (4 + t^2)
        let f' := (8 * y) / (4 + y^2)^2
        have hGLog: G = fun t ‚Ü¶ 1/4* Real.log (f t) := by
          unfold G f
          simp
        have h_f_deriv : HasDerivAt f f' y := by
          unfold f'
          let u:= fun t : ‚Ñù ‚Ü¶ t^2
          let v:= fun t : ‚Ñù ‚Ü¶ (4 + t^2)
          have : f= fun t:‚Ñù ‚Ü¶ u t/ v t:= by
            unfold f u v
            funext t
            simp
          rw[this]
          have hu : HasDerivAt u (2 * y) y := by
            unfold u
            convert hasDerivAt_pow 2 y
            simp
          have hv : HasDerivAt v (0+2 * y) y := by
            let v1:= fun t :‚Ñù ‚Ü¶ (4:‚Ñù)
            let v2:= fun t :‚Ñù ‚Ü¶ t^2
            have : v = v1+ v2 := by
              unfold v v1 v2
              funext t
              simp
            rw[this]
            have hv1 : HasDerivAt v1 0 y := by
              unfold v1
              exact hasDerivAt_const (c:=4) y
            have hv2 : HasDerivAt v2 (2 * y) y := by
              unfold v2
              convert hasDerivAt_pow 2 y
              simp
            apply HasDerivAt.add (f:=v1) (g:=v2) hv1 hv2
          simp at hv
          apply HasDerivAt.congr_deriv (HasDerivAt.div hu hv ?_)
          ¬∑ unfold u v at *
            field_simp
            ring_nf
          ¬∑ unfold v
            have : 0 < 4+ y ^ 2:= by
              have : 0 ‚â§ y ^ 2 := sq_nonneg y
              linarith
            linarith
        have h_f_pos : f y ‚â† 0 := by
          unfold f
          have pow_y: 0 < y ^ 2 := pow_pos hy 2
          have pow_y_plus_const: 0 < 4 + y ^ 2:=
          by linarith [sq_nonneg y]
          have:=div_pos pow_y pow_y_plus_const
          linarith


        have h_log_deriv : HasDerivAt (fun t ‚Ü¶   Real.log (f t)) (f' / f y) y := by
          apply HasDerivAt.log h_f_deriv h_f_pos

        unfold f f' at h_log_deriv
        unfold G
        field_simp at h_log_deriv
        have: 8 / (y * (4 + y ^ 2)) = 2/y - 2*y/ (4 + y^2):= by
          field_simp
          ring_nf
        simp_rw[this] at h_log_deriv
        have: -(1 / 2) * y / (4 + y ^ 2) + 1 / (2 * y)= 1/4*( 2/y - 2*y/ (4 + y^2)):= by
          field_simp
          ring_nf
        rw[this]
        exact h_log_deriv.const_mul (1 / 4)
      exact hg

    have h_deriv_eq : ‚àÄ y >0 ,
      HasDerivAt integral_neg_sinc_sq_times_id_exp (-(1/2) * y / (4 + y^2)+ 1 / (2 * y)) y ‚àß
      HasDerivAt G (-(1/2) * y / (4 + y^2)+ 1 / (2 * y)) y := by
        intro y hy
        refine ‚ü®hasDeriv_integral_neg_sinc_sq_times_id_exp' y hy, ?_‚ü©
        exact G_diff y hy


    have h_Hdiff : DifferentiableOn ‚Ñù H (Set.Ioi 0) := by
      intro y hy
      have hF_diff : DifferentiableAt ‚Ñù integral_neg_sinc_sq_times_id_exp y :=
    (hasDeriv_integral_neg_sinc_sq_times_id_exp' y hy).differentiableAt
      have hG : DifferentiableAt ‚Ñù G y :=
        (G_diff y hy).differentiableAt
      exact (hF_diff.sub hG).differentiableWithinAt


    have h_Hzero: ‚àÄ y > 0, HasDerivAt (fun y =>H y) 0 y := by
      intro y hy
      have hF := (h_deriv_eq y hy).1
      have hG := (h_deriv_eq y hy).2
      simpa using hF.sub hG

    have h_Hzero' : EqOn (deriv H) 0 (Set.Ioi 0) := by
      intro y hy
      have h := h_Hzero y hy
      simpa using h.deriv

    have hIoi_open : IsOpen (Set.Ioi (0 : ‚Ñù)) :=
      isOpen_Ioi

    have hIoi_preconnected : IsPreconnected (Set.Ioi (0 : ‚Ñù)) :=
      isPreconnected_Ioi

    have h_lim : Tendsto H atTop (ùìù 0) := by
      have hF_lim : Tendsto integral_neg_sinc_sq_times_id_exp atTop (ùìù 0) := by
        let h:= tendsto_integral_neg_sinc_sq_times_id_exp
        unfold integral_neg_sinc_sq_times_id_exp
        unfold neg_sinc_sq_times_id_exp
        exact h

      have hG_lim : Tendsto G atTop (ùìù 0) := by
        unfold G
        rw [show (0 : ‚Ñù) = 1 / 4 * 0 by ring]
        apply Tendsto.const_mul

        have h_log_cont : ContinuousAt Real.log 1 := continuousAt_log (by norm_num)
        rw[show (0 : ‚Ñù) = Real.log 1 by rw [Real.log_one]]
        apply (continuousAt_log (by norm_num)).tendsto.comp
        let f := fun t:‚Ñù ‚Ü¶ t^2
        have h_f : Tendsto f atTop atTop := tendsto_pow_atTop (by norm_num)
        have h_frac : Tendsto (fun k:‚Ñù ‚Ü¶ k ^ 2 / (4 + k ^ 2)) atTop (ùìù 1) := by
          have : Tendsto (fun k:‚Ñù ‚Ü¶ 1 / (4 * (1 / k ^ 2) + 1)) atTop (ùìù (1 / (4 * 0 + 1))) := by
            rw [show (fun k: ‚Ñù ‚Ü¶ (1:‚Ñù)/ ((4:‚Ñù) * ((1:‚Ñù) / k ^ 2) + (1:‚Ñù))) =( fun k:‚Ñù ‚Ü¶ ((4:‚Ñù) * (1 / k ^ 2) + (1:‚Ñù))‚Åª¬π) by ext; simp]
            rw [show (1 / (4 * 0 + 1) : ‚Ñù) = ((4 * 0 + 1)‚Åª¬π: ‚Ñù) by simp]
            apply Tendsto.inv‚ÇÄ
            apply Tendsto.add
            ¬∑ apply Tendsto.const_mul
              have: (fun k ‚Ü¶ 1 / k ^ 2)= fun k:‚Ñù ‚Ü¶  k ^ (-(2:‚Ñ§)):= by
                funext k
                simp
                rfl
              rw[this]
              have: 2‚â† 0:= by linarith
              exact tendsto_pow_neg_atTop this
            ¬∑ exact tendsto_const_nhds
            ¬∑ ring_nf
              linarith
          simp at this
          refine (tendsto_congr' ?_).mp this
          filter_upwards [eventually_gt_atTop 0] with k hk
          field_simp
        exact h_frac
      have: (0:‚Ñù) = 0-0 := by
        simp
      rw[this]
      unfold H
      apply Tendsto.sub
      ¬∑ exact hF_lim
      ¬∑ exact hG_lim

    have h_const : ‚àÄ a ‚àà Ioi 0, ‚àÄ b ‚àà Ioi 0, H a = H b := by
      intro a ha
      intro b hb
      apply IsOpen.is_const_of_deriv_eq_zero hIoi_open hIoi_preconnected h_Hdiff h_Hzero' ha hb

    have h_is_zero : ‚àÄ y ‚àà Ioi 0, H y = 0 := by
      intro y hy
      have h_ev : H =·∂†[atTop] (fun _ ‚Ü¶ H y) := by
        filter_upwards [eventually_gt_atTop 0] with b hb
        exact h_const b hb y hy
      apply tendsto_nhds_unique _ h_lim
      have h_lim_const : Tendsto H atTop (ùìù (H y)) := by
        exact tendsto_const_nhds.congr' h_ev.symm
      exact h_lim_const
    unfold H G at h_is_zero

    exact sub_eq_zero.mp (h_is_zero x hx)

lemma hasDeriv_integral_sinc_sq_times_exp'(x : ‚Ñù) (hx : 0 < x) : HasDerivAt (integral_sinc_sq_times_exp ) (1/4 * Real.log (x^2/(4+x^2))) x := by
  have h_deriv: HasDerivAt (integral_sinc_sq_times_exp) (integral_neg_sinc_sq_times_id_exp x) x := by
    exact hasDeriv_integral_sinc_sq_times_exp x hx
  have h_deriv_eq:integral_neg_sinc_sq_times_id_exp x = 1/4*Real.log (x^2/(4+x^2)):= integral_neg_sinc_sq_times_id_exp_eq x hx
  rw[h_deriv_eq] at h_deriv
  exact h_deriv

lemma h_log_ineq_neg1 : ‚àÄ y, -1/2 < y ‚Üí y ‚â§ 0 ‚Üí Real.log (1 + y) ‚â§ y - y^2 / 2 := by
  intro y hy_gt hy_le
  let f := fun t ‚Ü¶ Real.log (1 +t) - t + t^2 / 2
  have h_deriv : ‚àÄ x ‚àà Set.Icc y 0, HasDerivAt f (x^2 / (1 + x)) x := by
    intro x hx
    have : 0 < 1 + x := by linarith [hx.1]
    have h_neq:  1 + id x ‚â† 0:= by
      simp
      linarith
    unfold f
    convert (HasDerivAt.sub
    (HasDerivAt.log (hasDerivAt_id x |>.const_add 1) h_neq)
    (hasDerivAt_id x)).add ((hasDerivAt_id x).pow 2 |>.div_const 2) using 1
    simp
    field_simp
    ring_nf
  have hfy : f y ‚â§ 0 := by
    have hf0 : f 0 = 0 := by
      simp [f]
    rw [‚Üê hf0]
    have h_mono : MonotoneOn f (Icc y 0) := by
      apply monotoneOn_of_deriv_nonneg (convex_Icc y 0)
      ¬∑ apply ContinuousOn.add
        ¬∑ apply ContinuousOn.sub
          ¬∑ apply ContinuousOn.log
            refine Continuous.continuousOn ?_
            continuity
            intro z hz; linarith [hy_gt, hz.1]
          ¬∑ exact continuousOn_id
        ¬∑ refine Continuous.continuousOn ?_
          continuity
      ¬∑ intro x hx
        have hx_mem : x ‚àà Icc y 0 := by
          rw [interior_Icc] at hx
          exact Ioo_subset_Icc_self hx
        exact (h_deriv x hx_mem).differentiableAt.differentiableWithinAt
      ¬∑ intro u hu
        have hu_mem : u ‚àà Icc y 0 := by
          rw [interior_Icc] at hu
          exact Ioo_subset_Icc_self hu
        rw [(h_deriv u hu_mem).deriv]
        have hu_gt_neg1 : -1/2 < u := by
          rw [interior_Icc] at hu
          linarith [hy_gt, hu.1]
        have h_den : 0 < 1 + u := by linarith  [hu_gt_neg1]
        have h_pos : 0 ‚â§ u^2 / (1 + u) := by
          positivity
        exact h_pos
    apply h_mono
    ¬∑ exact left_mem_Icc.mpr hy_le
    ¬∑ exact right_mem_Icc.mpr hy_le
    ¬∑ exact hy_le
  unfold f at hfy
  linarith

lemma h_log_ineq_neg2 : ‚àÄ y, -1<y ‚Üí y <0 ‚Üí Real.log (1 + y)/y ‚â§ 1/(1+y) := by
  intro y hy_gt hy_lt

  let f := fun t ‚Ü¶ t  / (1+t)-Real.log (1 +t)
  have h_deriv : ‚àÄ x ‚àà Set.Icc y 0, HasDerivAt f  ( 1/(1+x)^2-1/(1+x) ) x := by
    intro x hx

    have : 0 < 1 + x := by linarith [hx.1]
    have h_neq:  1 + id x ‚â† 0:= by
      simp
      linarith
    unfold f
    apply HasDerivAt.sub
    ¬∑ have h_u : HasDerivAt (fun t ‚Ü¶ t) 1 x := hasDerivAt_id x
      have h_v : HasDerivAt (fun t ‚Ü¶ 1 + t) 1 x := by
        convert (hasDerivAt_const x 1).add (hasDerivAt_id x)
        simp
      have h_div := HasDerivAt.div h_u h_v (by linarith)
      field_simp at h_div
      have :  (1:‚Ñù) + x -x = (1:‚Ñù):= by
        ring_nf
      rw[this] at h_div
      convert h_div using 1
    ¬∑ let f:= fun t:‚Ñù ‚Ü¶ 1+t
      let f':= fun t:‚Ñù ‚Ü¶ (1:‚Ñù)
      have hx_pos : f x ‚â† 0 := by
        unfold f
        linarith[hx.left, hy_gt]
      have derivf: HasDerivAt f ((0:‚Ñù)+ (1:‚Ñù)) x:= by
        unfold f
        apply HasDerivAt.add
        ¬∑ exact hasDerivAt_const x 1
        ¬∑ exact hasDerivAt_id x
      have: (0:‚Ñù)+ 1=f' x:= by
        unfold f'
        simp
      rw[this] at derivf
      have h_log : HasDerivAt (fun t ‚Ü¶ Real.log (1 + t)) (1 / (1 + x)) x := by
        let h:=HasDerivAt.log derivf hx_pos
        unfold f f' at h
        exact h
      exact h_log

  have hfy : f y ‚â§  0 := by
    have hf0 : f 0 = 0 := by
      simp [f]
    rw [‚Üê hf0]
    have h_mono : MonotoneOn f (Icc y 0) := by
      unfold f
      apply monotoneOn_of_deriv_nonneg (convex_Icc y 0)
      ¬∑ apply ContinuousOn.add
        ¬∑ apply ContinuousOn.div
          ¬∑ exact continuousOn_id
          ¬∑ refine Continuous.continuousOn ?_
            continuity
          ¬∑ intro x hx
            have hx_low : y ‚â§ x := (mem_Icc.mp hx).1
            have hx_gt_neg1 : -1 < x := lt_of_lt_of_le hy_gt hx_low
            linarith
        ¬∑ apply ContinuousOn.neg
          apply ContinuousOn.log
          refine Continuous.continuousOn ?_
          continuity
          intro x hx
          have hx_low : y ‚â§ x := (mem_Icc.mp hx).1
          have hx_gt_neg1 : -1 < x := lt_of_lt_of_le hy_gt hx_low
          linarith

      ¬∑ intro x hx
        have hx_mem : x ‚àà Icc y 0 := by
          rw [interior_Icc] at hx
          exact Ioo_subset_Icc_self hx
        exact (h_deriv x hx_mem).differentiableAt.differentiableWithinAt
      ¬∑ intro u hu
        have hu_mem : u ‚àà Icc y 0 := by
          rw [interior_Icc] at hu
          exact Ioo_subset_Icc_self hu
        rw [(h_deriv u hu_mem).deriv]
        have hu_gt_neg1 : -1 < u := by
          rw [interior_Icc] at hu
          have:= hu.1
          linarith
        have h_den : 0 < 1 + u := by linarith  [hu_gt_neg1]
        field_simp [h_den.ne']
        ring_nf
        rw [interior_Icc] at hu
        have := hu.2
        linarith
    apply h_mono
    ¬∑ exact left_mem_Icc.mpr hy_lt.le
    ¬∑ exact right_mem_Icc.mpr hy_lt.le
    exact hy_lt.le
  unfold f at hfy
  have h_rw:  (y:‚Ñù)  / (1 + y) ‚â§ Real.log (1 + y) := by linarith
  have: (y:‚Ñù )/ (1 + y)=y * (1/(1 + y)):=by
    field_simp
  rw[this] at h_rw
  have h_div := (div_le_iff_of_neg'  (a:= 1/(1 + y)) (b:=Real.log (1 + y))  hy_lt).mpr h_rw
  exact h_div

theorem integral_sinc_sq_times_exp_eq (x : ‚Ñù) (hx : 0 < x) :
    integral_sinc_sq_times_exp x = x/4*Real.log (x^2/(4+x^2))+ Real.arctan (2/x) := by
    let G := fun t => t/4*Real.log (t^2/(4+t^2))+ Real.arctan (2/t)
    let H := fun t => integral_sinc_sq_times_exp t - G t
    have G_diff:  ‚àÄ y >0 , HasDerivAt G (1/4*Real.log (y^2/(4+y^2))) y := by
      intro y hy
      have h_log_deriv : HasDerivAt (fun t ‚Ü¶ Real.log (t^2 / (4 + t^2))) (2/y - 2*y/(4+y^2)) y := by

        have : (fun t ‚Ü¶ Real.log (t^2 / (4 + t^2))) =·∂†[ùìù y] (fun t ‚Ü¶ 2 * Real.log t - Real.log (4 + t^2)) := by
          filter_upwards [eventually_gt_nhds hy] with t ht
          rw [Real.log_div (pow_ne_zero 2 ht.ne') (by positivity)]
          rw [Real.log_pow]
          rfl

        refine HasDerivAt.congr_of_eventuallyEq ?_ this
        apply HasDerivAt.sub
        ¬∑ apply HasDerivAt.const_mul 2
          have hy_neq: y‚â†0 := by
            linarith
          exact hasDerivAt_log hy_neq
        ¬∑ let f:= fun (t:‚Ñù)‚Ü¶ 4 + t ^ 2
          let f':= fun (t:‚Ñù)‚Ü¶ 2*t
          have hf_y: f y ‚â† 0:= by
            unfold f
            have: 4+y^2>0:= by
              nlinarith
            linarith
          have hf_deriv: HasDerivAt f (f' y) y:= by
            unfold f f'
            have: 2*y= 0 +2*y:= by
              simp
            rw[this]
            apply HasDerivAt.add
            ¬∑ exact hasDerivAt_const y 4
            ¬∑ let h:= hasDerivAt_pow 2 y
              simp at h
              exact h
          apply HasDerivAt.log hf_deriv hf_y

      have h_arctan_deriv : HasDerivAt (fun t ‚Ü¶ Real.arctan (2/t)) ( -2/(4+y^2)) y := by
        have h_neq_y: id y ‚â† 0:= by
          simp
          linarith
        have h := HasDerivAt.arctan (hasDerivAt_const y 2 |>.div (hasDerivAt_id y) h_neq_y)
        simp at h
        convert h using 1
        field_simp [hy]
        ring_nf

      have h_prod_deriv : HasDerivAt (fun t:‚Ñù ‚Ü¶ t / 4 * Real.log (t ^ 2 / (4 + t ^ 2))) (1 / 4 * Real.log (y ^ 2 / (4 + y ^ 2)) + (y / 4) * (2 / y - 2 * y / (4 + y ^ 2))) y := by
        apply HasDerivAt.mul
        ¬∑ simp only [div_eq_inv_mul]
          apply HasDerivAt.const_mul
          exact hasDerivAt_id y
        ¬∑ exact h_log_deriv

      have h_G_full := h_prod_deriv.add h_arctan_deriv
      convert h_G_full using 1
      field_simp [hy.ne.symm, (by nlinarith : 4 + y^2 ‚â† 0)]
      have: 4 + y ^ 2 - y ^ 2= (4:‚Ñù):= by
        simp
      rw[this]
      ring_nf

    have h_deriv_eq : ‚àÄ y >0 ,
      HasDerivAt integral_sinc_sq_times_exp (1 / 4 * Real.log (y ^ 2 / (4 + y ^ 2))) y ‚àß
      HasDerivAt G (1 / 4 * Real.log (y ^ 2 / (4 + y ^ 2))) y := by
        intro y hy
        refine ‚ü®hasDeriv_integral_sinc_sq_times_exp' y hy, ?_‚ü©
        exact G_diff y hy


    have h_Hdiff : DifferentiableOn ‚Ñù H (Set.Ioi 0) := by
      intro y hy
      have hF_diff : DifferentiableAt ‚Ñù integral_sinc_sq_times_exp y :=
    (hasDeriv_integral_sinc_sq_times_exp' y hy).differentiableAt
      have hG : DifferentiableAt ‚Ñù G y :=
        (G_diff y hy).differentiableAt

      exact (hF_diff.sub hG).differentiableWithinAt


    have h_Hzero: ‚àÄ y > 0, HasDerivAt (fun y =>H y) 0 y := by
      intro y hy
      have hF := (h_deriv_eq y hy).1
      have hG := (h_deriv_eq y hy).2
      simpa using hF.sub hG

    have h_Hzero' : EqOn (deriv H) 0 (Set.Ioi 0) := by
      intro y hy
      have h := h_Hzero y hy
      simpa using h.deriv

    have hIoi_open : IsOpen (Set.Ioi (0 : ‚Ñù)) :=
      isOpen_Ioi

    have hIoi_preconnected : IsPreconnected (Set.Ioi (0 : ‚Ñù)) :=
      isPreconnected_Ioi

    have h_lim : Tendsto H atTop (ùìù 0) := by
      have hF_lim : Tendsto integral_sinc_sq_times_exp atTop (ùìù 0) := by
        let h:= tendsto_integral_sinc_sq_times_exp
        exact h

      have hG_lim : Tendsto G atTop (ùìù 0) := by
        unfold G
        have:  (ùìù (0:‚Ñù))= (ùìù ((0:‚Ñù)+(0:‚Ñù))):= by simp
        simp_rw[this]
        apply Tendsto.add
        ¬∑ let u := fun t:‚Ñù ‚Ü¶ -4 / (4 + t^2)
          have h_u : Tendsto u atTop (ùìù 0) := by
            apply tendsto_const_nhds.div_atTop
            apply tendsto_const_nhds.add_atTop
            exact tendsto_pow_atTop (by norm_num)

          have h_equiv : (fun t ‚Ü¶ t / 4 * Real.log (t^2 / (4 + t^2))) =
                     (fun t ‚Ü¶ (t * (-4 / (4 + t^2)) / 4) * (Real.log (1 + u t) / u t)) := by
            ext t
            unfold u
            field_simp
            ring_nf

          rw [h_equiv]
          have: (ùìù (0:‚Ñù ))= (ùìù ((0:‚Ñù )*(1:‚Ñù ))):= by simp
          rw[this]
          apply Tendsto.mul
          ¬∑ field_simp
            have: (ùìù (0:‚Ñù )) = ùìù (-(0:‚Ñù)):= by simp
            rw[this]
            apply Tendsto.neg
            apply tendsto_of_tendsto_of_tendsto_of_le_of_le' (f:= fun x:‚Ñù‚Ü¶ x / (4 + x ^ 2)) (g := fun _ ‚Ü¶ 0) (h:= fun x:‚Ñù ‚Ü¶ x / x ^ 2)
            ¬∑ exact tendsto_const_nhds
            ¬∑ have h: 1<2 := by linarith
              have:(fun x:‚Ñù ‚Ü¶ x / x ^ 2)= fun x:‚Ñù ‚Ü¶ x ^1 / x ^ 2:= by simp
              simp_rw[this]
              exact tendsto_pow_div_pow_atTop_zero (p:=1) (q:=2) h
            ¬∑ filter_upwards [eventually_gt_atTop 0] with x hx
              positivity
            ¬∑ filter_upwards [eventually_gt_atTop 0] with x hx
              field_simp
              ring_nf
              linarith
          ¬∑ let lower_x :=fun t:‚Ñù  ‚Ü¶ 1-(u t)/2
            let upper_x := fun t:‚Ñù  ‚Ü¶ 1/(1+u t)
            apply tendsto_of_tendsto_of_tendsto_of_le_of_le' (f:=fun x:‚Ñù‚Ü¶  Real.log (1 + u x) / u x) (g:=lower_x) (h:= upper_x)
            ¬∑ unfold lower_x
              have : (ùìù (1:‚Ñù) )= (ùìù ((1:‚Ñù)-(0:‚Ñù) )):= by simp
              rw[this]
              apply Tendsto.sub
              ¬∑ exact tendsto_const_nhds
              ¬∑ have : (ùìù (0:‚Ñù) )= (ùìù ((0:‚Ñù)/(2:‚Ñù) )):= by simp
                rw[this]
                apply Tendsto.div
                ¬∑ exact h_u
                ¬∑ exact tendsto_const_nhds
                ¬∑ linarith
            ¬∑ unfold upper_x
              have : (ùìù (1:‚Ñù) )= (ùìù ((1:‚Ñù)/(1:‚Ñù) )):= by simp
              rw[this]
              apply Tendsto.div
              ¬∑ exact tendsto_const_nhds
              ¬∑ have : (ùìù (1:‚Ñù) )= (ùìù ((1:‚Ñù)  +(0:‚Ñù) )):= by simp
                rw[this]
                apply Tendsto.add
                ¬∑ exact tendsto_const_nhds
                ¬∑ exact h_u
              linarith
            ¬∑ unfold lower_x
              have h_eventually : ‚àÄ·∂† t in atTop, -1/2 < u t := by
                apply h_u.eventually
                apply eventually_gt_nhds
                linarith
              have h_u_neg : ‚àÄ·∂† b in atTop, u b < 0 := by
                filter_upwards with b
                unfold u
                have : 0 < 4 + b^2 := by positivity
                field_simp [this]
                ring_nf
                linarith

              have h_log_ineq : ‚àÄ·∂† (b : ‚Ñù) in atTop, 1 - u b / 2 ‚â§ Real.log (1 + u b) / u b := by
                filter_upwards [h_eventually, h_u_neg] with b hb hb_neg
                rw[le_div_iff_of_neg hb_neg]

                have h := h_log_ineq_neg1 (u b) hb hb_neg.le
                linarith

              exact h_log_ineq
            ¬∑ unfold upper_x
              have h_eventually : ‚àÄ·∂† t in atTop, -1 < u t := by
                apply h_u.eventually
                apply eventually_gt_nhds
                linarith
              have h_u_neg : ‚àÄ·∂† b in atTop, u b < 0 := by
                filter_upwards with b
                unfold u
                have : 0 < 4 + b^2 := by positivity
                field_simp [this]
                ring_nf
                linarith
              filter_upwards [h_eventually,h_u_neg] with b hb_one hb_zero
              have:= h_log_ineq_neg2 ( u b) hb_one hb_zero
              exact this

        ¬∑ have h_inv : Tendsto (fun x:‚Ñù ‚Ü¶ 2 / x) atTop (ùìù 0) := by
            apply tendsto_const_nhds.div_atTop
            exact tendsto_id
          have h_cont : Tendsto Real.arctan (ùìù 0) (ùìù (Real.arctan 0)) :=
            Real.continuous_arctan.continuousAt.tendsto
          rw [Real.arctan_zero] at h_cont
          exact h_cont.comp h_inv

      unfold H
      have: (ùìù (0:‚Ñù ))= (ùìù ((0:‚Ñù )-(0:‚Ñù ))):= by simp
      rw[this]
      apply Tendsto.sub
      ¬∑ exact hF_lim
      ¬∑ exact hG_lim

    have h_const : ‚àÄ a ‚àà Ioi 0, ‚àÄ b ‚àà Ioi 0, H a = H b := by
      intro a ha
      intro b hb
      apply IsOpen.is_const_of_deriv_eq_zero hIoi_open hIoi_preconnected h_Hdiff h_Hzero' ha hb

    have h_is_zero : ‚àÄ y ‚àà Ioi 0, H y = 0 := by
      intro y hy
      have h_ev : H =·∂†[atTop] (fun _ ‚Ü¶ H y) := by
        filter_upwards [eventually_gt_atTop 0] with b hb
        exact h_const b hb y hy
      apply tendsto_nhds_unique _ h_lim
      have h_lim_const : Tendsto H atTop (ùìù (H y)) := by
        exact tendsto_const_nhds.congr' h_ev.symm
      exact h_lim_const
    unfold H G at h_is_zero

    exact sub_eq_zero.mp (h_is_zero x hx)

theorem integral_sinc_sq_eq_pi_div_two :
    ‚à´ t in Ioi 0, (sinc t)^2 = œÄ / 2 := by
  have h_lim_int : Tendsto (fun x => integral_sinc_sq_times_exp x) (ùìù[>] 0) (ùìù (‚à´ t in Ioi 0, (sinc t)^2)) := by
    refine tendsto_integral_filter_of_dominated_convergence (fun t => (Real.sinc t)^2) ?_ ?_ ?_ ?_
    ¬∑ filter_upwards [self_mem_nhdsWithin] with x (hx : 0 < x)
      apply ContinuousOn.aestronglyMeasurable
      unfold sinc_sq_times_exp
      apply ContinuousOn.mul
      ¬∑ apply Continuous.continuousOn
        apply Continuous.rexp
        continuity
      ¬∑ apply Continuous.continuousOn
        apply Continuous.pow
        exact Real.continuous_sinc
      ¬∑ exact measurableSet_Ioi
    ¬∑ filter_upwards [self_mem_nhdsWithin] with u (hu : 0 < u)
      rw [ae_restrict_iff' measurableSet_Ioi]
      refine ae_of_all _ (fun t (ht : 0 < t) => ?_)
      unfold sinc_sq_times_exp
      rw [norm_mul, Real.norm_eq_abs, Real.norm_eq_abs]
      rw [abs_of_nonneg (exp_pos _).le]
      simp
      refine mul_le_of_le_one_left (sq_nonneg _) ?_
      rw [exp_le_one_iff]
      nlinarith
    ¬∑exact integrable_sinc_sq
    ¬∑ rw [ae_restrict_iff' measurableSet_Ioi]
      refine ae_of_all _ (fun t (ht : 0 < t) => ?_)
      unfold sinc_sq_times_exp
      have : ùìù (sinc t ^ 2)= ùìù (1*sinc t ^ 2):= by simp
      rw[this]
      apply Tendsto.mul
      ¬∑ apply (tendsto_exp_nhds_zero_nhds_one.comp ?_)
        have h0 : Tendsto (fun n:‚Ñù
           ‚Ü¶ n) (ùìù[>] 0) (ùìù 0) :=
          tendsto_id.mono_left nhdsWithin_le_nhds
        have: ùìù ( 0:‚Ñù ) = ùìù (-0 * t):= by simp
        rw[this]
        exact h0.neg.mul_const t
      ¬∑ exact tendsto_const_nhds
  have h_lim_int2 : Tendsto (fun x ‚Ü¶ integral_sinc_sq_times_exp x) (ùìù[>] 0) (ùìù (œÄ / 2)) := by
    refine (tendsto_congr' (f‚ÇÅ := fun x ‚Ü¶ integral_sinc_sq_times_exp x) (f‚ÇÇ := fun x ‚Ü¶ (x / 4) * Real.log (x^2 / (4 + x^2)) + Real.arctan (2 / x)) ?_).mpr ?_
    ¬∑ filter_upwards [self_mem_nhdsWithin] with x hx
      exact integral_sinc_sq_times_exp_eq x hx
    ¬∑ have h_lim_arctan : Tendsto (fun x:‚Ñù ‚Ü¶ Real.arctan (2 / x)) (ùìù[>] (0:‚Ñù)) (ùìù ((œÄ:‚Ñù ) / 2)) := by
        have h_atTop : Tendsto (fun x:‚Ñù  ‚Ü¶ 2 / x) (ùìù[>] 0) atTop := by
          have h_rewrite : (fun x:‚Ñù ‚Ü¶ 2 / x) = (fun x ‚Ü¶ 2 * (1 / x)) := by
            ext x
            ring_nf
          rw [h_rewrite]
          apply Tendsto.const_mul_atTop (by norm_num : (0 : ‚Ñù) < 2)
          simp[HDiv.hDiv,  Div.div,  DivInvMonoid.div']
          exact tendsto_inv_nhdsGT_zero
        exact (Real.tendsto_arctan_atTop.comp h_atTop).mono_right nhdsWithin_le_nhds
      have h_lim_log : Tendsto (fun x ‚Ü¶ (x / 4) * Real.log (x^2 / (4 + x^2))) (ùìù[>] 0) (ùìù 0) := by
        let g := fun x:‚Ñù ‚Ü¶ (1 / 2) * (x * Real.log x) - (x / 4) * Real.log (4 + x^2)
        refine (tendsto_congr' (f‚ÇÅ := fun x:‚Ñù ‚Ü¶ (x / 4) * Real.log (x^2 / (4 + x^2))) (f‚ÇÇ := g) ?_).mpr ?_
        ¬∑ filter_upwards [self_mem_nhdsWithin] with x (hx : 0 < x)
          have hx_ne : x ‚â† 0 := hx.ne'
          have hx_sq_ne : x^2 ‚â† 0 := by nlinarith
          have h_pos :  4 + x^2‚â† 0 := by linarith [pow_two_nonneg x]
          rw [Real.log_div hx_sq_ne h_pos, Real.log_pow, mul_sub]
          ring
        ¬∑ unfold g
          have: (ùìù (0:‚Ñù))= (ùìù (0-0:‚Ñù)):= by
            simp
          rw[this]
          apply Tendsto.sub
          ¬∑ have h_zero : (0 : ‚Ñù) = (1 / 2) * 0 := by simp
            rw [h_zero]
            apply Tendsto.mul
            ¬∑ exact tendsto_const_nhds
            ¬∑ let g := fun u ‚Ü¶ Real.exp (-u) * Real.log (Real.exp (-u))
              have h_comp : Tendsto g atTop (ùìù 0) := by
                have h_g_eq : ‚àÄ u, g u = - (u * Real.exp (-u)) := by
                  intro u
                  simp [g]
                  ring
                have h_growth := Real.tendsto_pow_mul_exp_neg_atTop_nhds_zero 1
                simp at h_growth
                have : Tendsto (fun u ‚Ü¶ - (u * Real.exp (-u))) atTop (ùìù (-0)) :=
                  h_growth.neg
                simp at this
                rw [funext h_g_eq]
                exact this
              simp
              have h_final : Tendsto (fun x ‚Ü¶ g (- Real.log x)) (ùìù[>] 0) (ùìù 0) := by
                apply h_comp.comp
                have h_log := Real.tendsto_log_nhdsGT_zero
                exact tendsto_neg_atBot_atTop.comp h_log
              unfold g at h_final
              simp at h_final
              refine (tendsto_congr' ?_).mp h_final
              filter_upwards [self_mem_nhdsWithin] with x hx
              rw [Real.exp_log hx]
          ¬∑ have: (ùìù (0:‚Ñù))= (ùìù (0*    Real.log 4)):= by simp
            rw[this]
            apply Tendsto.mul
            ¬∑ apply   tendsto_nhdsWithin_of_tendsto_nhds
              have h_cont : Continuous (fun x : ‚Ñù ‚Ü¶ x / 4) := by
                exact continuous_id.div_const (4:‚Ñù )
              have h_lim := h_cont.tendsto 0
              simp at h_lim
              exact h_lim
            ¬∑ apply   tendsto_nhdsWithin_of_tendsto_nhds
              apply Tendsto.log
              ¬∑ have h_cont : Continuous (fun x:‚Ñù ‚Ü¶ 4 + x ^ 2) := by
                  apply Continuous.add
                  exact continuous_const
                  apply Continuous.pow
                  continuity
                have h_lim := h_cont.tendsto 0
                simp at h_lim
                exact h_lim
              ¬∑ linarith
      have h_somme := h_lim_log.add h_lim_arctan
      simp at h_somme
      exact h_somme
  exact tendsto_nhds_unique h_lim_int h_lim_int2

lemma h_lim_T: Tendsto (fun T ‚Ü¶ (sinc (T / 2))^2 * (T / 2)) (atTop : Filter ‚Ñù) (ùìù 0) := by
  let FilterT := (atTop : Filter ‚Ñù)
  let g := fun t ‚Ü¶ (sinc t)^2 * t
  let f:= fun (T:‚Ñù) ‚Ü¶ T / 2
  have h_comp : Tendsto (fun (T:‚Ñù) ‚Ü¶ T / 2) FilterT FilterT := by
    let c : ‚Ñù := 1/2
    have hc : 0 < c := by norm_num
    have h_eq : (fun( T:‚Ñù) ‚Ü¶ T / 2) = (fun T ‚Ü¶ T * c) := by
      unfold c; ext; field_simp;
    rw[h_eq]
    apply tendsto_id.atTop_mul_const hc
  have: (fun a ‚Ü¶ sinc (a / 2) ^ 2 * (a / 2)) = fun a ‚Ü¶ (g‚àò f) a:= by
    unfold f g
    simp
  rw[this]
  refine Tendsto.comp (y := atTop) ?_ h_comp
  unfold g
  exact limit_sinc_sq_mul_self_atTop


theorem integral_dirichlet :
    Tendsto (fun T: ‚Ñù ‚Ü¶(‚à´ t in 0..T, Real.sinc t))  (atTop : Filter ‚Ñù) (ùìù (œÄ/2)):= by
  have h_eq : ‚àÄ·∂† T in atTop, (‚à´ t in 0..T, Real.sinc t) =
      (‚à´ t in 0..T/2, (Real.sinc t)^2) + (Real.sinc (T/2))^2 * (T/2) := by
    filter_upwards [eventually_gt_atTop 0] with T hT
    exact integral_sinc_zero_T T hT
  rw [tendsto_congr' h_eq]
  have: ùìù (œÄ / 2)= (ùìù (œÄ / 2+0)):= by simp
  rw[this]
  apply Tendsto.add
  ¬∑ have h_comp : Tendsto (fun T:‚Ñù ‚Ü¶ T / 2) atTop atTop := by
      simp_rw[div_eq_mul_inv]
      apply tendsto_id.atTop_mul_const
      linarith
    have h_int_lim : Tendsto (fun x ‚Ü¶ ‚à´ t in 0..x/2, (sinc t)^2) atTop (ùìù (‚à´ t in Ioi 0, (sinc t)^2)) := MeasureTheory.intervalIntegral_tendsto_integral_Ioi 0 integrable_sinc_sq h_comp
    rw[integral_sinc_sq_eq_pi_div_two] at h_int_lim
    exact h_int_lim
  ¬∑ exact h_lim_T
