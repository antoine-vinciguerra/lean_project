import Mathlib.Tactic.Basic

import Mathlib.MeasureTheory.Integral.Bochner.Basic
import Mathlib.MeasureTheory.Integral.Bochner.L1
import Mathlib.MeasureTheory.Integral.Bochner.VitaliCaratheodory
import Mathlib.MeasureTheory.Integral.Bochner.ContinuousLinearMap
import Mathlib.MeasureTheory.Integral.Lebesgue.Basic
import Mathlib.MeasureTheory.Integral.IntervalIntegral
import Mathlib.MeasureTheory.Integral.Lebesgue.Countable
import Mathlib.Dynamics.Ergodic.MeasurePreserving
import Mathlib.MeasureTheory.Integral.Lebesgue.Basic
import Mathlib.MeasureTheory.Integral.Lebesgue.Norm
import Mathlib.MeasureTheory.Measure.Lebesgue.Complex
import Mathlib.MeasureTheory.Integral.Prod
import Mathlib.Analysis.Calculus.ParametricIntegral
import Mathlib.Topology.Instances.Complex
import Mathlib.Analysis.SpecialFunctions.Exponential
import Mathlib.Algebra.GroupWithZero.Action.Defs
import Mathlib.Analysis.Complex.Basic
import Mathlib.Analysis.Fourier.FourierTransform
import Mathlib.Analysis.SpecialFunctions.ImproperIntegrals

import Mathlib.Algebra.Group.Basic
import Mathlib.Algebra.Group.Semiconj.Defs
import Mathlib.Algebra.Group.Commute.Basic
import Mathlib.Algebra.Group.Commute.Defs
import LaplaceTransform.LaplaceTransformDef
import Mathlib.MeasureTheory.Measure.Complex
import Mathlib.Analysis.Complex.Exponential

import Mathlib.Data.Complex.Basic
import Mathlib.Data.List.Defs
import Mathlib.Analysis.SpecialFunctions.Integrals.Basic
import Mathlib.Order.Filter.Basic
/-! # The Dirichlet Integral
-/


@[expose] public section


noncomputable section


open MeasureTheory Filter
open MeasureTheory Set
open MeasureTheory Complex Real Topology Filter
open scoped Topology
open Complex

noncomputable def DirichletSin : ‚Ñù ‚Üí ‚Ñù :=
  fun x‚Ü¶1/2 + 1/œÄ * ‚à´ t in  (0).. (x), sinc t

noncomputable def HeavisidePerso (x : ‚Ñù) : ‚Ñù :=
  if x > 0 then 1 else if x = 0 then 1/2 else 0


def sin_div_times_exp (t : ‚Ñù) : ‚Ñù ‚Üí ‚Ñù := fun x ‚Ü¶ Real.exp (-x * t) * (Real.sin t / t)

def neg_sin_times_exp (t : ‚Ñù) : ‚Ñù ‚Üí ‚Ñù := fun x ‚Ü¶ -Real.sin t * Real.exp (-x * t)
def integral_sin_div_times_exp_eps (Œµ : ‚Ñù)(h_Œµ : Œµ>0): ‚Ñù ‚Üí ‚Ñù  := fun x ‚Ü¶ ‚à´ t in Ioi Œµ , sin_div_times_exp t x

def integral_sin_div_times_exp (x: ‚Ñù) : ‚Ñù  := ‚à´ t in Ioi 0 , sin_div_times_exp t x

lemma sin_div_times_exp_le_exp (t : ‚Ñù) (ht : 0 < t):
‚àÄ x, ‚Äñsin_div_times_exp t x‚Äñ ‚â§ Real.exp (-x * t):= by
  intro x
  unfold sin_div_times_exp
  rw [norm_mul]
  have:  ‚Äñrexp (-x * t)‚Äñ= rexp (-x * t):= by
    simp
  rw[this]
  apply mul_le_of_le_one_right (exp_pos _).le
  have : sinc t= Real.sin t / t := by
    have h_t_neq_0:  t ‚â† 0:= by
      exact ht.ne'
    exact Real.sinc_of_ne_zero h_t_neq_0
  rw[‚Üê this]

  rw[ Real.norm_eq_abs]
  simp[Real.abs_sinc_le_one]

lemma hasDeriv_sin_div_times_exp(t : ‚Ñù) (ht : 0 < t):
  ‚àÄa: ‚Ñù ,HasDerivAt (sin_div_times_exp t) (neg_sin_times_exp t a) a:= by
    unfold neg_sin_times_exp
    unfold sin_div_times_exp
    intro a
    have h_inner : HasDerivAt (fun x => -x * t) (-t) a := by
      simpa using hasDerivAt_id a |>.neg |>.mul_const t

    have h_exp : HasDerivAt (fun x => Real.exp (-x * t)) (-t * Real.exp (-a * t)) a := by
      convert h_inner.exp using 1
      ring
    convert h_exp.mul_const (Real.sin t / t) using 1
    field_simp

lemma neg_sin_times_exp_le_exp (t: ‚Ñù):
  ‚àÄ x, ‚Äñneg_sin_times_exp t x‚Äñ ‚â§ Real.exp (-x * t):= by
  intro x
  unfold neg_sin_times_exp
  rw [norm_mul]
  have:  ‚Äñrexp (-x * t)‚Äñ= rexp (-x * t):= by
    simp
  rw[this]
  apply mul_le_of_le_one_left
  have h_exp_pos_le:  0 ‚â§ rexp (-(x * t)):= by
    have h_exp_pos : 0 < Real.exp (-(x * t)) := Real.exp_pos (-(x * t))
    simp[h_exp_pos.le]
  have: rexp (-(x * t))= rexp (-x * t):= by
    simp
  rw[ this] at h_exp_pos_le
  exact h_exp_pos_le
  simp only [norm_neg, norm_eq_abs]
  simp[abs_sin_le_one]


theorem hasDeriv_integral_sin_div_times_exp (x : ‚Ñù) (hx : 0 < x) :
    HasDerivAt (integral_sin_div_times_exp) (- ‚à´ t in Ioi 0, Real.sin t * Real.exp (-x * t)) x := by
  classical
  have h_deriv :‚àÄ t ‚àà Ioi 0,
      HasDerivAt
        (fun x => sin_div_times_exp t x)
        (neg_sin_times_exp t x)
        x :=
  by
    intro t ht
    have ht_gt0 : t > 0 := by
      apply mem_Ioi.mp ht
    exact hasDeriv_sin_div_times_exp t ht_gt0 x

  have hF_AEmeas : ‚àÄ·∂† x' in nhds x, AEStronglyMeasurable (fun t => sin_div_times_exp t x') (volume.restrict (Ioi 0)) := by
    apply Filter.Eventually.of_forall
    intro x'
    unfold sin_div_times_exp
    apply ContinuousOn.aestronglyMeasurable
    ¬∑ apply ContinuousOn.mul
      apply Continuous.continuousOn
      have: Continuous (fun x ‚Ü¶ -x' * x):= by
        continuity
      apply Continuous.rexp this
      apply ContinuousOn.div
      apply Continuous.continuousOn
      continuity
      apply Continuous.continuousOn
      continuity
      intro t ht
      rw [mem_Ioi] at ht
      exact ht.ne'
    ¬∑ exact measurableSet_Ioi

  have h_int_x :
    IntegrableOn (fun t => Real.exp (-x * t)) (Ioi 0) volume :=
  by
    have h_neg : -x < 0 := by linarith [hx]
    exact integrableOn_exp_mul_Ioi h_neg 0

  have hF_int : Integrable (fun t => sin_div_times_exp t x) (volume.restrict (Ioi 0)) :=by
    apply MeasureTheory.Integrable.mono h_int_x
    ¬∑ exact hF_AEmeas.self_of_nhds
    ¬∑ rw [ae_restrict_iff' measurableSet_Ioi]
      refine Filter.Eventually.of_forall (fun t ht_mem => ?_)
      have ht_pos : 0 < t := by
        rw [mem_Ioi] at ht_mem
        exact ht_mem
      have : ‚Äñrexp (-x * t)‚Äñ= rexp (-x * t):= by
        simp only [neg_mul, norm_eq_abs, abs_exp]
      rw[this]
      exact sin_div_times_exp_le_exp t ht_pos x

  have hF'_meas : MeasureTheory.AEStronglyMeasurable (fun t => neg_sin_times_exp t x) (volume.restrict (Ioi 0)) := by
    unfold neg_sin_times_exp
    apply ContinuousOn.aestronglyMeasurable
    ¬∑ apply ContinuousOn.mul
      apply Continuous.continuousOn
      continuity
      apply Continuous.continuousOn
      have: Continuous (fun x' ‚Ü¶ -x * x'):= by
        continuity
      apply Continuous.rexp this
    ¬∑ exact measurableSet_Ioi

  let r := x / 2
  have hr : r > 0 := by
    unfold r
    simp[hx]

  let bound_func := fun t => Real.exp (-r * t)

  have h_bound : ‚àÄ·µê t ‚àÇvolume.restrict (Ioi 0), ‚àÄ x' ‚àà Metric.ball x r,
      ‚Äñneg_sin_times_exp t x'‚Äñ ‚â§ bound_func t := by
    rw [ae_restrict_iff' measurableSet_Ioi]
    refine Filter.Eventually.of_forall (fun t ht_mem x' hx' => ?_)
    have ht_pos : 0 < t := by
      rw[mem_Ioi] at ht_mem
      exact ht_mem
    unfold bound_func
    have  first_ineq: ‚Äñ neg_sin_times_exp t x'‚Äñ‚â§ rexp (-x' * t) := by
      exact neg_sin_times_exp_le_exp t x'
    have second_ineq : rexp (-x' * t) ‚â§ rexp (-r * t):= by
      apply Real.exp_le_exp.mpr
      apply mul_le_mul_of_nonneg_right
      rw [Metric.mem_ball, Real.dist_eq] at hx'
      have h_ineg_rx'x :  -r < x' - x := (abs_lt.mp hx').1
      have: x-r < x':= by
        linarith [h_ineg_rx'x]
      have h_r_x_2 : x-r=r := by
        unfold r
        ring_nf
      rw[h_r_x_2] at this
      have h_res: -x' < -r := by
        linarith
      exact h_res.le
      exact ht_pos.le
    exact le_trans first_ineq second_ineq
  have h_bound_int : Integrable bound_func (volume.restrict (Ioi 0)) := by
    apply (integrableOn_exp_mul_Ioi (by linarith) 0).integrable

  have h_diff : ‚àÄ·µê t ‚àÇvolume.restrict (Ioi 0), ‚àÄ x' ‚àà Metric.ball x r,
      HasDerivAt (fun x_param => sin_div_times_exp t x_param) (neg_sin_times_exp t x') x' := by
    rw [ae_restrict_iff' measurableSet_Ioi]
    refine Filter.Eventually.of_forall (fun t ht_mem x' _ => ?_)
    have ht_pos : 0 < t := by
      rw[mem_Ioi] at ht_mem
      exact ht_mem
    exact hasDeriv_sin_div_times_exp t ht_pos x'
  have h_final := hasDerivAt_integral_of_dominated_loc_of_deriv_le
    hr hF_AEmeas hF_int hF'_meas h_bound h_bound_int h_diff
  have : (fun t => neg_sin_times_exp t x) = (fun t => - (Real.sin t * Real.exp (-x * t))) := by
    ext t
    unfold neg_sin_times_exp
    ring
  rw [this] at h_final
  rw [integral_neg] at h_final
  exact h_final.2

theorem compute_deriv_integral_sin_div_times_exp_eps(Œµ : ‚Ñù)(x : ‚Ñù) (hx : 0 < x) :
- ‚à´ t in Ioi Œµ, Real.sin t * Real.exp (-x * t)=-rexp (-x * Œµ) * (Real.cos Œµ + Real.sin Œµ * x) / (1 + x^2) :=by
  apply (Complex.ofReal_inj).mp

  calc  ‚Üë(-‚à´ (t : ‚Ñù) in Ioi Œµ, Real.sin t * rexp (-x * t))
    _ = - ‚à´ t in Ioi Œµ, (Real.sin t * rexp (-x * t) : ‚ÑÇ) := by
      simp only [ofReal_neg]
      simp[‚Üêintegral_complex_ofReal]
    _=- ‚à´ t in Ioi Œµ, (Real.sin t:‚ÑÇ) * (rexp (-x * t) : ‚ÑÇ):= by
      congr
    _= - ‚à´ t in Ioi Œµ, (Real.sin t:‚ÑÇ) * cexp (-x * ‚Üët) := by
      congr
      simp
    _ = - ‚à´ t in Ioi Œµ, ((cexp (I * ‚Üët) - cexp (-I * ‚Üët)) / (2 * I)) * cexp (-x * ‚Üët):= by
       congr
       funext t
       simp
       have h_sin : Complex.sin t = (Complex.exp (-t * I) - Complex.exp (t * I)) * I / 2 := by
        rw [‚Üê Complex.two_sin]
        simp
       simp_rw [h_sin]
       field_simp [I_ne_zero]
       rw [I_sq]
       ring_nf
    _ = - ‚à´ t in Ioi Œµ, ((cexp (I * ‚Üët- x*‚Üët) - cexp (-I*‚Üët-x * ‚Üët)) / (2 * I)) := by
      congr
      funext t
      field_simp
      have h_distrib : (cexp (I * t) - cexp (-(I * t))) * cexp (-(t * x)) =
        cexp (t * (I - x)) - cexp (t * (-I - x)) := by
        rw [sub_mul, ‚Üê Complex.exp_add, ‚Üê Complex.exp_add]
        ring_nf
      rw[h_distrib]
    _=- ‚à´ t in Ioi Œµ, ((cexp (‚Üët*(I- x) ) - cexp (-‚Üët*(I+x))) / (2 * I)) := by
      congr
      funext t
      field_simp
      have:  cexp (t * (I - x)) - cexp (t * (-I - x)) = cexp (t * (I - x)) - cexp (-(t * (I + x))) := by
        congr 1
        ring_nf
      rw[this]
    _=-1/(2 * I)* ‚à´ t in Ioi Œµ, (cexp (‚Üët*(I- x) ) - cexp (-‚Üët*(I+x))) := by
      simp_rw [div_eq_mul_inv, mul_comm _ (2 * I)‚Åª¬π]
      rw [integral_mul_left (2 * I)‚Åª¬π]
      field_simp
      congr
      funext t
      field_simp
    _ = - 1 / (2 * I) * ((‚à´ t in Ioi Œµ, cexp (t * (I - x))) - ‚à´ t in Ioi Œµ, cexp (-t * (I + x))) := by
      have: ‚à´ t in Ioi Œµ, (cexp (‚Üët*(I- x) ) - cexp (-‚Üët*(I+x)))= (‚à´ t in Ioi Œµ, cexp (t * (I - x))) - ‚à´ t in Ioi Œµ, cexp (-t * (I + x)):= by
        have hf : Integrable (fun (t:‚Ñù) ‚Ü¶ (cexp (‚Üët * (I - ‚Üëx)) : ‚ÑÇ)) (volume.restrict (Ioi Œµ)) := by
          rw [‚Üê integrable_norm_iff]
          simp_rw [Complex.norm_exp]
          simp only [mul_re, I_re, I_im, ofReal_re, ofReal_im, add_re,
               mul_zero, sub_self, zero_add, neg_mul, zero_mul, sub_zero]
          have: (fun a ‚Ü¶ rexp (a * (I - ‚Üëx).re))= (fun a ‚Ü¶ rexp ( (I - ‚Üëx).re* a)):= by
            funext a
            field_simp
          rw[this]
          have: (I - ‚Üëx).re<0:= by
            simp
            exact hx
          exact integrableOn_exp_mul_Ioi this Œµ
          apply ContinuousOn.aestronglyMeasurable
          apply Continuous.continuousOn
          apply Continuous.cexp
          apply Continuous.mul
          ¬∑ exact continuous_ofReal
          ¬∑ exact continuous_const
          exact measurableSet_Ioi
        have hg : Integrable (fun (t:‚Ñù) ‚Ü¶ (cexp (-t * (I + x))))  (volume.restrict (Ioi Œµ)) := by
          rw [‚Üê integrable_norm_iff]
          simp_rw [Complex.norm_exp]
          simp only [mul_re, I_re, I_im, ofReal_re, ofReal_im, add_re,
               mul_zero, sub_self, zero_add, neg_mul, zero_mul, sub_zero]
          have: (fun (a:‚Ñù) ‚Ü¶  rexp (-(‚Üëa * (I + ‚Üëx))).re) = (fun (a:‚Ñù) ‚Ü¶ rexp ((-I -‚Üëx).re* a)):= by
            funext a
            field_simp
            have h_re_right : (-I - ‚Üëx).re = -x := by
              simp [sub_re, I_re, ofReal_re]
            rw[h_re_right]
            have h_arg : -(‚Üëa * (I + ‚Üëx)) = (-a * x : ‚Ñù) + (-a : ‚Ñù) * I := by
              ring_nf
              simp [I_re, I_im]
              ring
            rw [h_arg]
            have h_exp_mul: (‚Üë(-a * x) + ‚Üë(-a) * I).re = (-a * x):= by
              rw[Complex.add_re]
              simp [Complex.ofReal_re]
            rw [h_exp_mul]
            field_simp
          rw[this]
          have: (-I - ‚Üëx).re<0:= by
            simp
            exact hx
          exact integrableOn_exp_mul_Ioi this Œµ
          apply ContinuousOn.aestronglyMeasurable
          apply Continuous.continuousOn
          apply Continuous.cexp
          apply Continuous.mul
          ¬∑ continuity
          ¬∑ exact continuous_const
          exact measurableSet_Ioi
        have h_sub: ‚à´ t in Ioi Œµ, (cexp (‚Üët*(I- x) ) - cexp (-‚Üët*(I+x))) =
         (‚à´ t in Ioi Œµ, cexp (t * (I - x))) - ‚à´ t in Ioi Œµ, cexp (-t * (I + x)) := by
          exact integral_sub hf hg
        rw[h_sub]
      rw[this]
    _= -1 / (2 * I) * (-cexp ((I - ‚Üëx) * ‚ÜëŒµ) / (I - ‚Üëx) - ‚à´ (t : ‚Ñù) in Ioi Œµ, cexp (-‚Üët * (I + ‚Üëx))):= by
      let a := I - ‚Üëx
      have h_re : a.re < 0 := by
        unfold a
        simp [sub_re, I_re, ofReal_re]
        exact hx

      have h_int_val : ‚à´ (t : ‚Ñù) in Ioi Œµ, cexp (‚Üët*a) = - cexp (a*‚ÜëŒµ) / a := by
        have :‚à´ (t : ‚Ñù) in Ioi Œµ, cexp (‚Üët*a) = ‚à´ (t : ‚Ñù) in Ioi Œµ, cexp (a*‚Üët):= by
          congr
          funext t
          field_simp
        rw[this]
        apply  integral_exp_mul_complex_Ioi h_re Œµ
      unfold a at h_int_val
      rw[h_int_val]
    _= -1 / (2 * I) * (-cexp ((I - ‚Üëx) * ‚ÜëŒµ) / (I - ‚Üëx)  -cexp (-(I + ‚Üëx) * ‚ÜëŒµ) / (I + ‚Üëx)) := by
      let a := -(I +‚Üëx)
      have h_re : a.re < 0 := by
        unfold a
        simp [sub_re, I_re, ofReal_re]
        exact hx
      have : ‚à´ (t : ‚Ñù) in Ioi Œµ, cexp (-‚Üët * (I + ‚Üëx))=‚à´ (t : ‚Ñù) in Ioi Œµ, cexp (a*‚Üët):= by
        congr
        funext t
        unfold a
        field_simp
      rw[this]
      rw[integral_exp_mul_complex_Ioi h_re Œµ]
      unfold a
      field_simp
    _=1 / (2 * I) * (cexp ((I - ‚Üëx) * ‚ÜëŒµ) / (I - ‚Üëx)  +cexp (-(I + ‚Üëx) * ‚ÜëŒµ) / (I + ‚Üëx)) := by
      ring
    _=1 / (2 * I) * (cexp ((I - ‚Üëx) * ‚ÜëŒµ) *(I + ‚Üëx)/ ((I - ‚Üëx)*(I + ‚Üëx) ) +cexp (-(I + ‚Üëx) * ‚ÜëŒµ) / (I + ‚Üëx)) := by
      have h1 : I - ‚Üëx ‚â† 0 := by
        intro h
        have h_re := congr_arg Complex.re h
        simp at h_re
        exact hx.ne' h_re
      have h2 : I + ‚Üëx ‚â† 0 := by
        intro h
        have h_re := congr_arg Complex.re h
        simp at h_re
        exact hx.ne' h_re
      field_simp
    _=1 / (2 * I) * (cexp ((I - ‚Üëx) * ‚ÜëŒµ) *(I + ‚Üëx)/ ((I - ‚Üëx)*(I + ‚Üëx) ) +cexp (-(I + ‚Üëx) * ‚ÜëŒµ)*(I - ‚Üëx) /((I - ‚Üëx)*(I + ‚Üëx) )) := by
      have h1 : I - ‚Üëx ‚â† 0 := by
        intro h
        have h_re := congr_arg Complex.re h
        simp at h_re
        exact hx.ne' h_re
      have h2 : I + ‚Üëx ‚â† 0 := by
        intro h
        have h_re := congr_arg Complex.re h
        simp at h_re
        exact hx.ne' h_re
      field_simp
    _=1 / (2 * I) * (cexp ((I - ‚Üëx) * ‚ÜëŒµ) *(I + ‚Üëx)+ cexp (-(I + ‚Üëx) * ‚ÜëŒµ)*(I - ‚Üëx))/ ((I - ‚Üëx)*(I + ‚Üëx) ) := by
      ring
    _=-1 / (2 * I) * (cexp ((I - ‚Üëx) * ‚ÜëŒµ) *(I + ‚Üëx)+ cexp (-(I + ‚Üëx) * ‚ÜëŒµ)*(I - ‚Üëx))/(1+x^2):= by
      have h_denom : (I - ‚Üëx) * (I + ‚Üëx) = -(1 + ‚Üëx^2) := by
        ring_nf
        simp only [I_sq]
      rw [h_denom]
      field_simp
    _=-1 / (2 * I) *(cexp (- ‚Üëx* ‚ÜëŒµ)* cexp (I* ‚ÜëŒµ)*(I + ‚Üëx)+ cexp (- ‚Üëx* ‚ÜëŒµ)*cexp (-(I* ‚ÜëŒµ))*(I - ‚Üëx))/(1+x^2):=by
      field_simp
      have:  cexp ((I - ‚Üëx) * ‚ÜëŒµ) =cexp (-(‚Üëx * ‚ÜëŒµ))* cexp (I * ‚ÜëŒµ):= by
        simp_rw [sub_mul, exp_sub (I * ‚ÜëŒµ) ]
        field_simp
        rw [‚ÜêComplex.exp_add]
        ring_nf
        rw [Complex.exp_zero]
      rw[this]
      have: cexp (-(‚ÜëŒµ * (I + ‚Üëx)))= cexp (-(‚Üëx * ‚ÜëŒµ))* cexp (-(I * ‚ÜëŒµ)):= by
        simp_rw [Complex.exp_neg, mul_add, exp_add (‚ÜëŒµ * I) ]
        field_simp
      rw[this]
      field_simp
    _=-1 / (2 * I) *cexp (- ‚Üëx* ‚ÜëŒµ)*(cexp (I* ‚ÜëŒµ)*(I + ‚Üëx)+ cexp (-(I* ‚ÜëŒµ))*(I - ‚Üëx) )/(1+x^2):= by
      ring
    _=-1 / (2 * I) *cexp (- ‚Üëx* ‚ÜëŒµ)*( (cexp (I* ‚ÜëŒµ)+cexp (-(I* ‚ÜëŒµ)))*I + (cexp (I* ‚ÜëŒµ)-cexp (-(I* ‚ÜëŒµ)))* ‚Üëx )/(1+x^2):= by
      field_simp
      ring
    _=-1 / (2 * I) *cexp (- ‚Üëx* ‚ÜëŒµ)* ((2 * Complex.cos Œµ) * I+ (2 * I * Complex.sin Œµ) * ‚Üëx) / (1 + ‚Üëx^2) := by
      have h_sin : Complex.sin Œµ = (cexp (-(I* ‚ÜëŒµ))-cexp (I* ‚ÜëŒµ) )* I / 2 := by
        have : cexp (-‚ÜëŒµ*I)-cexp ( ‚ÜëŒµ*I)= cexp (-(I* ‚ÜëŒµ))-cexp (I* ‚ÜëŒµ):= by
          field_simp
        rw[‚Üê this]
        rw [‚Üê Complex.two_sin]
        simp
      have h_cos : Complex.cos Œµ = (cexp (I * ‚ÜëŒµ) + cexp (-(I * ‚ÜëŒµ))) / 2 := by
        have : cexp (‚ÜëŒµ*I)+cexp ( -‚ÜëŒµ*I)= cexp (I * ‚ÜëŒµ) + cexp (-(I * ‚ÜëŒµ)):= by
          field_simp
        rw[‚Üê this]
        rw [‚Üê Complex.two_cos]
        simp
      rw [h_sin, h_cos]
      field_simp [I_ne_zero, h_sin]
      congr
      rw [mul_add, mul_add]
      have: I * (I * ‚Üëx * (cexp (-(I * ‚ÜëŒµ)) - cexp (I * ‚ÜëŒµ)))= -‚Üëx * (cexp (-(I * ‚ÜëŒµ)) - cexp (I * ‚ÜëŒµ)):= by
        have: I * (I * ‚Üëx * (cexp (-(I * ‚ÜëŒµ)) - cexp (I * ‚ÜëŒµ)))=
              I * (I * (‚Üëx * (cexp (-(I * ‚ÜëŒµ)) - cexp (I * ‚ÜëŒµ)))):= by
              field_simp
        rw[this]
        rw [‚Üê mul_assoc I I (‚Üëx * (cexp (-(I * ‚ÜëŒµ)) - cexp (I * ‚ÜëŒµ))) , I_mul_I]
        ring_nf
      rw[this]
      ring
    _=-1 / (2 * I)*2*I  *cexp (- ‚Üëx* ‚ÜëŒµ)* (( Complex.cos Œµ)+ ( Complex.sin Œµ) * ‚Üëx) / (1 + ‚Üëx^2) := by
      field_simp
    _=-cexp (- ‚Üëx* ‚ÜëŒµ)* (( Complex.cos Œµ)+ ( Complex.sin Œµ) * ‚Üëx) / (1 + ‚Üëx^2) := by
      field_simp
    _=-rexp (- x* Œµ)* (( Complex.cos Œµ)+ ( Complex.sin Œµ) * ‚Üëx) / (1 + ‚Üëx^2) := by
      have : cexp (- ‚Üëx* ‚ÜëŒµ)= cexp (‚Üë(- x* Œµ)):= by
        push_cast
        simp
      rw[this]
      rw[Complex.ofReal_exp]
    _=-rexp (- x* Œµ)* ( Real.cos Œµ+ Real.sin Œµ * ‚Üëx) / (1 + ‚Üëx^2) := by
      rw[Complex.ofReal_cos]
      rw[Complex.ofReal_sin]
    _= -‚Üë(rexp (-x * Œµ)) * (‚Üë(Real.cos Œµ) + ‚Üë(Real.sin Œµ) * ‚Üëx) / ‚Üë((1 : ‚Ñù) + x^2):= by
      push_cast
      field_simp
    _= ‚Üë(-rexp (-x * Œµ) * (Real.cos Œµ + Real.sin Œµ * x) / ((1 : ‚Ñù) + x^2)):= by
      push_cast
      field_simp

theorem hasDeriv_integral_sin_div_times_exp' (x : ‚Ñù) (hx : 0 < x) : HasDerivAt (integral_sin_div_times_exp) (- 1 / (1 + x^2)) x:= by
  have h_deriv: HasDerivAt (integral_sin_div_times_exp) (- ‚à´ t in Ioi 0, Real.sin t * Real.exp (-x * t)) x := by
    exact hasDeriv_integral_sin_div_times_exp x hx

  rw[compute_deriv_integral_sin_div_times_exp_eps 0 x hx] at h_deriv
  have h_val : -rexp (-x * 0) * (Real.cos 0 + Real.sin 0 * x) / (1 + x ^ 2) = -1 / (1 + x ^ 2) := by
    simp only [ Real.cos_zero, Real.sin_zero, zero_mul, add_zero, mul_one]
    have :-rexp (-x * 0)= -1:= by
      simp
    rw[this]

  exact h_deriv.congr_deriv h_val


lemma tendsto_integral_sin_div_exp :
    Tendsto (fun x : ‚Ñù ‚Ü¶ ‚à´ t in Ioi 0, rexp (-x * t) * (Real.sin t / t)) atTop (ùìù 0) := by
  classical
  rw [tendsto_zero_iff_norm_tendsto_zero]
  let f := fun x : ‚Ñù ‚Ü¶ ‚Äñ‚à´ t in Ioi 0, (Real.sin t / t) * rexp (-x * t)‚Äñ
  let g : ‚Ñù ‚Üí ‚Ñù := fun _ ‚Ü¶ 0
  let h := fun x : ‚Ñù ‚Ü¶ 1 / x
  apply tendsto_of_tendsto_of_tendsto_of_le_of_le' (g := g) (h := h)
  ¬∑ exact tendsto_const_nhds
  ¬∑ unfold h
    simp_rw[one_div]
    exact tendsto_inv_atTop_zero
  ¬∑ exact Eventually.of_forall (fun x ‚Ü¶ norm_nonneg _)
  ¬∑ filter_upwards [eventually_gt_atTop 0] with x hx_pos
    dsimp [f, h]
    have h_int_exp : ‚à´ t in Ioi 0, rexp (-x * t) = 1 / x := by
      rw [integral_exp_mul_Ioi (neg_neg_of_pos hx_pos) 0]
      simp [ mul_zero, Real.exp_zero]
    rw [‚Üê h_int_exp]
    rw [‚Üê Real.norm_eq_abs]
    apply norm_integral_le_of_norm_le
    ¬∑ have h_neq : ‚à´ (t : ‚Ñù) in Ioi 0, rexp (-x * t) ‚â† 0 := by
        rw [h_int_exp]
        exact one_div_ne_zero (ne_of_gt hx_pos)

      apply MeasureTheory.Integrable.of_integral_ne_zero
      exact h_neq
    ¬∑ filter_upwards [self_mem_ae_restrict (measurableSet_Ioi : MeasurableSet (Ioi (0:‚Ñù)))] with t ht
      have ht_pos : 0 < t := mem_Ioi.mp ht
      rw [norm_mul, norm_eq_abs (rexp _), abs_exp]
      field_simp
      rw [norm_eq_abs]
      rw [abs_div]
      rw[ div_le_one]
      ¬∑ simp[abs_sin_le_abs]
      ¬∑ rw [abs_eq_self.mpr ht_pos.le]
        exact ht_pos


theorem integral_sin_div_times_exp_eq_arctan (x : ‚Ñù) (hx : 0 < x) :
    integral_sin_div_times_exp x = Real.pi / 2 - Real.arctan x := by
    let G := fun x => Real.pi / 2 - Real.arctan x
    let H := fun x => integral_sin_div_times_exp x - G x
    have G_diff:  ‚àÄ y >0 , HasDerivAt G (-1 / (1 + y^2)) y := by
        intro y hy
        have hg : HasDerivAt G (0 - 1 / (1 + y^2)) y := by
          apply HasDerivAt.sub
          ¬∑ exact hasDerivAt_const y (Real.pi / 2)
          ¬∑ exact hasDerivAt_arctan y
        simp at hg;field_simp at hg
        have:-(1 / (1 + y ^ 2))= -1 / (1 + y ^ 2):= by
          ring_nf
        rw[this] at hg
        exact hg

    have h_deriv_eq : ‚àÄ y >0 ,
      HasDerivAt integral_sin_div_times_exp (-1 / (1 + y^2)) y ‚àß
      HasDerivAt G (-1 / (1 + y^2)) y := by
        intro y hy
        refine ‚ü®hasDeriv_integral_sin_div_times_exp' y hy, ?_‚ü©
        exact G_diff y hy


    have h_Hdiff : DifferentiableOn ‚Ñù H (Set.Ioi 0) := by
      intro y hy
      have hF_diff : DifferentiableAt ‚Ñù integral_sin_div_times_exp y :=
    (hasDeriv_integral_sin_div_times_exp' y hy).differentiableAt
      have hG : DifferentiableAt ‚Ñù G y :=
        (G_diff y hy).differentiableAt
      exact (hF_diff.sub hG).differentiableWithinAt


    have h_Hzero: ‚àÄ y > 0, HasDerivAt (fun y =>H y) 0 y := by
      intro y hy
      have hF := (h_deriv_eq y hy).1
      have hG := (h_deriv_eq y hy).2
      simpa using hF.sub hG

    have h_Hzero' : EqOn (deriv H) 0 (Set.Ioi 0) := by
      intro y hy
      have h := h_Hzero y hy
      simpa using h.deriv

    have hIoi_open : IsOpen (Set.Ioi (0 : ‚Ñù)) :=
      isOpen_Ioi

    have hIoi_preconnected : IsPreconnected (Set.Ioi (0 : ‚Ñù)) :=
      isPreconnected_Ioi

    have h_lim : Tendsto H atTop (ùìù 0) := by
      have hF_lim : Tendsto integral_sin_div_times_exp atTop (ùìù 0) := by
        let h:= tendsto_integral_sin_div_exp
        unfold integral_sin_div_times_exp
        unfold sin_div_times_exp
        exact h

      have hG_lim : Tendsto G atTop (ùìù 0) := by
        simp [G]
        rw [‚Üê sub_self (œÄ / 2)]
        apply Tendsto.sub
        ¬∑ exact tendsto_const_nhds
        ¬∑ exact tendsto_arctan_atTop.mono_left (le_refl _) |>.mono_right nhdsWithin_le_nhds
      convert Tendsto.sub hF_lim hG_lim
      simp
    have h_const : ‚àÄ a ‚àà Ioi 0, ‚àÄ b ‚àà Ioi 0, H a = H b := by
      intro a ha
      intro b hb
      apply IsOpen.is_const_of_deriv_eq_zero hIoi_open hIoi_preconnected h_Hdiff h_Hzero' ha hb
    have h_is_zero : ‚àÄ y ‚àà Ioi 0, H y = 0 := by
      intro y hy
      have h_ev : H =·∂†[atTop] (fun _ ‚Ü¶ H y) := by
        filter_upwards [eventually_gt_atTop 0] with b hb
        exact h_const b hb y hy
      apply tendsto_nhds_unique _ h_lim
      have h_lim_const : Tendsto H atTop (ùìù (H y)) := by
        exact tendsto_const_nhds.congr' h_ev.symm
      exact h_lim_const
    unfold H G at h_is_zero
    exact sub_eq_zero.mp (h_is_zero x hx)

theorem integral_dirichlet_from_Feynman :
    Tendsto integral_sin_div_times_exp (ùìù[>] 0) (ùìù (œÄ / 2)) := by
  apply Tendsto.congr'
  ¬∑ filter_upwards [self_mem_nhdsWithin] with x hx
    rw [integral_sin_div_times_exp_eq_arctan x hx]
  ¬∑ have h_atan : Tendsto arctan (ùìù[>] 0) (ùìù 0) := by
      have h := continuous_arctan.tendsto 0
      rw [arctan_zero] at h
      exact h.mono_left nhdsWithin_le_nhds
    have h_const : Tendsto (fun _ : ‚Ñù ‚Ü¶ œÄ / 2) (ùìù[>] 0) (ùìù (œÄ / 2)) := tendsto_const_nhds
    simpa using h_const.sub h_atan
